<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P Ä N I K - Raidsheet</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .bg-slate-850 { background-color: #1a202c; }
        .bg-slate-750 { background-color: #2d3748; }
        .bg-slate-900 { background-color: #0d1117; }
        .border-slate-650 { border-color: #4a5568; }
        .text-blue-450 { color: #63b3ed; }
        .nav-link { background-color: #4a5568; }
        .nav-link.active-tab { background-color: #4299e1; box-shadow: 0 2px 4px rgba(0,0,0,0.3); transform: translateY(-2px); }
        #auth-section { position: absolute; top: 1rem; right: 1rem; }
        /* Stile für comp.html -- hier zentralisiert */
        .role-btn { padding: 0.1rem 0.5rem; font-size: 0.75rem; border-radius: 4px; border: 1px solid #4a5568; background-color: #2d3748; color: #a0aec0; opacity: 0.6; transition: all 0.2s; }
        .role-btn:not(.disabled):hover { opacity: 1; border-color: #a0aec0; }
        .role-btn.active { opacity: 1; font-weight: bold; color: #ffffff; }
        .role-btn.role-tank.active { background-color: #2563eb; border-color: #60a5fa; }
        .role-btn.role-healer.active { background-color: #059669; border-color: #34d399; }
        .role-btn.role-dps.active { background-color: #dc2626; border-color: #f87171; }
        .player-details { display: flex; align-items: center; min-width: 0; }
        .editable-name { background-color: transparent; border: 1px solid transparent; border-radius: 4px; padding: 2px 4px; transition: all 0.2s; max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .editable-name:not(:disabled):hover, .editable-name:not(:disabled):focus { background-color: rgba(255, 255, 255, 0.1); border-color: #4a5568; max-width: none; }
        .editable-class-select { background-color: #2d3748; border: none; font-size: 0.8rem; border-radius: 4px; margin-left: 8px; }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            text-align: center;
            color: #e2e8f0;
            width: 90%;
            max-width: 400px;
        }
        .modal-content h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #63b3ed;
        }
        .modal-content p {
            margin-bottom: 1.5rem;
            color: #cbd5e0;
        }
        .modal-buttons button {
            background-color: #4299e1;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-weight: bold;
            transition: background-color 0.2s;
            margin: 0 0.5rem;
        }
        .modal-buttons button:hover {
            background-color: #3182ce;
        }
        .modal-buttons .cancel-btn {
            background-color: #e53e3e;
        }
        .modal-buttons .cancel-btn:hover {
            background-color: #c53030;
        }
        /* New: Login Modal specific styles */
        .login-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .login-modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            text-align: center;
            color: #e2e8f0;
            width: 90%;
            max-width: 400px;
        }
        .login-modal-content h3 {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            color: #63b3ed;
        }
        .login-modal-content input {
            background-color: #0d1117;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            border-radius: 4px;
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            width: 100%;
        }
        .login-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .login-modal-buttons button {
            background-color: #4299e1;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .login-modal-buttons button:hover {
            background-color: #3182ce;
        }
        .login-modal-buttons .cancel-btn {
            background-color: #e53e3e;
        }
        .modal-buttons .cancel-btn:hover {
            background-color: #c53030;
        }

        /* Spezifische Stile für Boss-Seiten (von steinwache.html übernommen) */
        .size-toggle-btn {
            transition: background-color 0.3s, color 0.3s;
        }
        .active-size-btn {
            background-color: #16a34a !important; /* Grüner Hintergrund für den aktiven Button */
            color: #ffffff !important;
            font-weight: 600;
        }
        .assignment-select {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 4px;
            padding: 4px 8px;
            width: 100%;
            color: white;
        }
        .assignment-select:disabled {
            opacity: 0.5;
        }
        .editor-info {
            font-size: 0.75rem;
            color: #a0aec0;
            margin-left: 8px;
        }
    </style>
</head>
<body class="bg-slate-850 text-gray-200 p-4 sm:p-8">

    <div class="max-w-7xl mx-auto bg-slate-750 p-6 rounded-lg shadow-lg relative">
        <div id="auth-section"></div>
        <header class="text-center pb-4 mb-6 border-b border-slate-650">
            <h1 class="text-4xl font-bold text-white">P Ä N I K Raidsheet</h1>
             <div class="flex justify-center items-center gap-2 mt-2">
                <p class="text-lg text-gray-400">Strategien und Einteilungen</p>
                <div id="presence-indicator" class="flex items-center gap-2 text-sm text-gray-400"></div>
            </div>
        </header>

        <h2 class="text-2xl font-semibold text-center text-blue-450 mb-4">Navigation</h2>
        <div class="flex justify-center mb-4">
            <label for="raid-selector" class="sr-only">Raid auswählen</label>
            <select id="raid-selector" class="bg-slate-850 text-gray-200 p-2 rounded-md border border-slate-650 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="mogushan" selected>Mogu'shan Gewölbe</option>
                <!-- Weitere Raids können hier hinzugefügt werden, z.B.: -->
                <!-- <option value="herausforderung">Terrasse des Endlosen Frühlings</option> -->
            </select>
        </div>
        <nav id="boss-nav" class="flex flex-wrap justify-center gap-2 mb-8">
            <a href="#comp" data-page-id="comp" class="nav-link bg-green-700 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">Übersicht & Comp</a>
            <a href="#mogushan/steinwache" data-page-id="mogushan/steinwache" class="nav-link hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">Die Steinwache</a>
            <a href="#mogushan/feng" data-page-id="mogushan/feng" class="nav-link hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">Feng der Verfluchte</a>
            <a href="#mogushan/garajal" data-page-id="mogushan/garajal" class="nav-link hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">Gara'jal der Geisterbinder</a>
            <a href="#mogushan/geisterkoenige" data-page-id="mogushan/geisterkoenige" class="nav-link hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">Die Geisterkönige</a>
            <a href="#mogushan/elegon" data-page-id="mogushan/elegon" class="nav-link hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">Elegon</a>
            <a href="#mogushan/wille" data-page-id="mogushan/wille" class="nav-link hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">Der Wille des Kaisers (Jan-xi und Qin-xi)</a>
            <a href="#history" data-page-id="history" class="nav-link bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">Änderungsverlauf</a>
        </nav>

        <main id="content-container">
            <!-- Inhalt wird hier dynamisch geladen -->
        </main>
    </div>

    <!-- Login Modal HTML Structure -->
    <div id="login-modal-overlay" class="login-modal-overlay hidden">
        <div class="login-modal-content">
            <h3>Gildenrat-Login</h3>
            <input type="text" id="login-username" placeholder="Benutzername" required>
            <input type="password" id="login-password" placeholder="Passwort" required>
            <div class="login-modal-buttons">
                <button id="login-modal-cancel-btn" class="cancel-btn">Abbrechen</button>
                <button id="login-modal-submit-btn">Login</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK & Hauptlogik -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc, getDoc, serverTimestamp, query, orderBy, addDoc, updateDoc, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // ============== INITIALISIERUNG & GLOBALE VARIABLEN ==============
        const firebaseConfig = {
            apiKey: "AIzaSyBmqCCIOKq0OQOTEgJJ7Lj8CYlLihVBVSU",
            authDomain: "panik-raid.firebaseapp.com",
            projectId: "panik-raid",
            storageBucket: "panik-raid.appspot.com",
            messagingSenderId: "120578974053",
            appId: "1:120578974053:web:927a81dccbb4b33f86c18c"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        window.isManager = false; // Global verfügbar machen
        let currentRosterUnsubscribe = null;
        let historyUnsubscribe = null;
        let assignmentUnsubscribe = null;
        let heartbeatIntervalId = null; // Global variable for heartbeat interval

        const DATA_COLLECTION = "raid-tool-data";
        const HISTORY_COLLECTION = "raid-tool-history";
        const USER_PROFILES_COLLECTION = "user_profiles";

        const classColors = { 'DEATHKNIGHT': '#C41F3B', 'DK': '#C41F3B', 'DRUID': '#FF7D0A', 'HUNTER': '#AAD372', 'MAGE': '#3FC7EB', 'MONK': '#00FF96', 'PALADIN': '#F48CBA', 'PRIEST': '#FFFFFF', 'ROGUE': '#FFF569', 'SHAMAN': '#0070DD', 'WARLOCK': '#8788EE', 'WARRIOR': '#C69B6D', 'TANK': '#A3A3A3' };
        const wowClasses = ['WARRIOR', 'PALADIN', 'HUNTER', 'ROGUE', 'PRIEST', 'DEATHKNIGHT', 'SHAMAN', 'MAGE', 'WARLOCK', 'MONK', 'DRUID'];
        const rosterDocRef = doc(db, DATA_COLLECTION, "currentRoster");
        const historyCollectionRef = collection(db, HISTORY_COLLECTION);
        const userProfilesCollectionRef = collection(db, USER_PROFILES_COLLECTION);

        // ============== MODAL-FUNKTION (global verfügbar) ==============
        window.showModal = function(message, isConfirm = false) { // Global verfügbar gemacht
            return new Promise((resolve) => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.innerHTML = `
                    <div class="modal-content">
                        <h3>Nachricht</h3>
                        <p>${message}</p>
                        <div class="modal-buttons">
                            ${isConfirm ? `<button id="modal-cancel-btn" class="cancel-btn">Abbrechen</button>` : ''}
                            <button id="modal-ok-btn">OK</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('modal-ok-btn').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });

                if (isConfirm) {
                    document.getElementById('modal-cancel-btn').addEventListener('click', () => {
                        document.body.removeChild(modalOverlay);
                        resolve(false);
                    });
                }
            });
        };

        // ============== LOGIN MODAL FUNKTION ==============
        function showLoginModal() {
            return new Promise((resolve) => {
                const loginModalOverlay = document.getElementById('login-modal-overlay');
                const loginUsernameInput = document.getElementById('login-username');
                const loginPasswordInput = document.getElementById('login-password');
                const loginSubmitBtn = document.getElementById('login-modal-submit-btn');
                const loginCancelBtn = document.getElementById('login-modal-cancel-btn');

                loginUsernameInput.value = ''; // Felder leeren
                loginPasswordInput.value = '';
                loginModalOverlay.classList.remove('hidden'); // Modal anzeigen

                const handleSubmit = async () => {
                    const username = loginUsernameInput.value;
                    const password = loginPasswordInput.value;

                    if (!username || !password) {
                        window.showModal("Bitte Benutzername und Passwort eingeben.");
                        return;
                    }

                    try {
                        // Schritt 1: Finde die E-Mail und den Manager-Status basierend auf dem Benutzernamen in Firestore
                        const q = query(userProfilesCollectionRef, where("username", "==", username));
                        const querySnapshot = await getDocs(q);

                        if (querySnapshot.empty) {
                            window.showModal("Benutzername nicht gefunden.");
                            return;
                        }

                        const userProfile = querySnapshot.docs[0].data();
                        const email = userProfile.email;
                        const isManagerFlag = userProfile.isManager || false;

                        // Schritt 2: Verwende die abgerufene E-Mail und das eingegebene Passwort für Firebase Auth
                        const userCredential = await signInWithEmailAndPassword(auth, email, password);

                        if (isManagerFlag) {
                            sessionStorage.setItem('currentManager', username);
                            loginModalOverlay.classList.add('hidden');
                            location.reload();
                            resolve(true);
                        } else {
                            await signOut(auth);
                            window.showModal("Dieses Konto ist keinem Gildenrat-Status zugeordnet.");
                            resolve(false);
                        }
                    } catch (error) {
                        console.error("Login-Fehler:", error);
                        let errorMessage = "Unbekannter Login-Fehler.";
                        if (error.code === 'auth/wrong-password' || error.code === 'auth/user-not-found' || error.code === 'auth/invalid-credential') {
                            errorMessage = "Falscher Benutzername oder falsches Passwort.";
                        } else if (error.code === 'auth/invalid-email') {
                            errorMessage = "Ungültiges E-Mail-Format (interner Fehler). Bitte überprüfe die E-Mail im Firestore user_profiles Dokument.";
                        }
                        window.showModal(errorMessage);
                        resolve(false);
                    }
                };

                const handleCancel = () => {
                    loginModalOverlay.classList.add('hidden');
                    resolve(false);
                };

                loginSubmitBtn.addEventListener('click', handleSubmit);
                loginCancelBtn.addEventListener('click', handleCancel);

                loginModalOverlay.addEventListener('click', function clickOutside(event) {
                    if (event.target === loginModalOverlay) {
                        handleCancel();
                    }
                });
            });
        }


        // ============== AUTHENTIFIZIERUNG & PRESENCE ==============
        async function setupAuthUI() {
            const authSection = document.getElementById('auth-section');
            const currentManagerUsername = sessionStorage.getItem('currentManager');

            if (currentManagerUsername) {
                const q = query(userProfilesCollectionRef, where("username", "==", currentManagerUsername));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const userProfile = querySnapshot.docs[0].data();
                    if (userProfile.isManager) {
                        window.isManager = true;
                        authSection.innerHTML = `<span class="text-white">Angemeldet als: <strong>${currentManagerUsername}</strong></span><button id="logout-btn" class="ml-2 bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-md text-sm">Logout</button>`;
                        document.getElementById('logout-btn').addEventListener('click', async () => {
                            await signOut(auth);
                            sessionStorage.removeItem('currentManager');
                            location.hash = '';
                            location.reload();
                        });
                        return;
                    }
                }
                sessionStorage.removeItem('currentManager');
            }

            window.isManager = false;
            authSection.innerHTML = `<button id="login-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-md text-sm">Gildenrat-Login</button>`;
            document.getElementById('login-btn').addEventListener('click', showLoginModal);
        }

        onAuthStateChanged(auth, user => {
            const presenceIndicator = document.getElementById('presence-indicator');

            // Clear any existing heartbeat interval
            if (heartbeatIntervalId) {
                clearInterval(heartbeatIntervalId);
                heartbeatIntervalId = null;
            }

            if (!user) {
                signInAnonymously(auth).catch(e => console.error("Anonymer Login-Fehler:", e));
                presenceIndicator.innerHTML = `<div class="w-3 h-3 bg-gray-500 rounded-full"></div><span>0</span> Online`;
                return;
            }

            const userStatusRef = doc(db, "presence", user.uid);

            // Function to update last_changed timestamp
            const updatePresenceTimestamp = () => {
                setDoc(userStatusRef, { online: true, last_changed: serverTimestamp() }, { merge: true })
                    .catch(e => console.error("Fehler beim Aktualisieren des Präsenz-Zeitstempels:", e));
            };

            // Initial set of presence
            updatePresenceTimestamp();

            // Set up heartbeat to update timestamp every 5 minutes (300 seconds)
            heartbeatIntervalId = setInterval(updatePresenceTimestamp, 5 * 60 * 1000); // Update every 5 minutes

            // Listen for real-time updates on the presence collection
            onSnapshot(collection(db, "presence"), snap => {
                const nowInSeconds = Date.now() / 1000; // Current time in seconds since epoch
                const onlineUsersCount = snap.docs.filter(doc => {
                    const data = doc.data();
                    // Consider user online if last_changed was within the last 6 minutes (360 seconds)
                    // This gives a buffer for the 5-minute heartbeat interval
                    return data.online && data.last_changed && (nowInSeconds - data.last_changed.seconds < (6 * 60));
                }).length;
                presenceIndicator.innerHTML = `<div class="w-3 h-3 bg-green-400 rounded-full animate-pulse"></div><span>${onlineUsersCount}</span> Online`;
            }, (error) => {
                console.error("Fehler beim Abrufen der Präsenz-Updates:", error);
                presenceIndicator.innerHTML = `<div class="w-3 h-3 bg-red-400 rounded-full"></div><span>Fehler</span>`;
            });
        });


        // ============== NAVIGATION & CONTENT LOADING ==============
        const contentContainer = document.getElementById('content-container');
        let currentRaidFolder = 'mogushan'; // Standard-Raid-Ordner

        async function loadContent(pageId) {
            // Unsubscribe from previous listeners to prevent memory leaks/multiple listeners
            if (currentRosterUnsubscribe) { currentRosterUnsubscribe(); currentRosterUnsubscribe = null; }
            if (historyUnsubscribe) { historyUnsubscribe(); historyUnsubscribe = null; }
            if (assignmentUnsubscribe) { assignmentUnsubscribe(); assignmentUnsubscribe = null; }

            let filePath = '';
            // Determine if it's a root-level page or a boss page within a raid folder
            if (pageId === 'comp' || pageId === 'history') {
                filePath = `${pageId}.html`;
            } else {
                // Assume boss pages are always prefixed with a folder (e.g., "mogushan/steinwache")
                filePath = `${pageId}.html`;
            }

            try {
                const response = await fetch(filePath);
                if (!response.ok) throw new Error(`Seite ${filePath} nicht gefunden.`);
                contentContainer.innerHTML = await response.text();
                // Extract only the actual boss ID for initializePage, removing the folder prefix if present
                const actualPageIdForInit = pageId.includes('/') ? pageId.split('/')[1] : pageId;
                initializePage(actualPageIdForInit);
            } catch (error) {
                console.error("Fehler beim Laden des Inhalts:", error);
                contentContainer.innerHTML = `<p class="text-center text-red-500">Fehler: Der Inhalt für '${filePath}' konnte nicht geladen werden.</p>`;
            }
        }

        function handleNavigation() {
            const raidSelector = document.getElementById('raid-selector');
            if (raidSelector) {
                // Update the currentRaidFolder based on the selector's value
                currentRaidFolder = raidSelector.value;
            }

            let hash = window.location.hash.substring(1);
            let pageIdToLoad = '';

            // Logic to determine the correct pageId to load based on hash and currentRaidFolder
            if (!hash || hash === 'comp' || hash === 'history') {
                pageIdToLoad = hash || 'comp'; // Default to 'comp' if hash is empty
            } else {
                // If a boss page is requested (e.g., #steinwache or #mogushan/steinwache)
                // We need to ensure the hash reflects the current raid selection.
                // If the hash already includes a folder, use that.
                // If not, assume it's a boss ID and prepend the currentRaidFolder.
                if (hash.includes('/')) {
                    // Hash already contains a folder (e.g., mogushan/steinwache)
                    pageIdToLoad = hash;
                } else {
                    // Hash is just boss name (e.g., steinwache), prepend current raid folder
                    pageIdToLoad = `${currentRaidFolder}/${hash}`;
                }
            }

            // Update the URL hash if it's different from what we're about to load,
            // to keep the URL consistent with the loaded content.
            // This is especially useful if a user types #steinwache and we load #mogushan/steinwache
            if (window.location.hash.substring(1) !== pageIdToLoad) {
                window.history.replaceState(null, '', `#${pageIdToLoad}`);
            }

            loadContent(pageIdToLoad);

            // Update active class in navigation
            document.querySelectorAll('#boss-nav .nav-link').forEach(link => {
                link.classList.toggle('active-tab', link.dataset.pageId === pageIdToLoad);
            });
        }

        window.addEventListener('hashchange', handleNavigation);
        document.addEventListener('DOMContentLoaded', () => {
             setupAuthUI();

             const raidSelector = document.getElementById('raid-selector');
             if (raidSelector) {
                 raidSelector.addEventListener('change', () => {
                     // When raid changes, force navigation to the 'comp' page or a default boss of the new raid.
                     // For now, let's just set the hash to 'comp' and let handleNavigation handle the rest.
                     // This ensures a consistent starting point when switching raids.
                     window.location.hash = '#comp';
                     // handleNavigation will be triggered by the hashchange event if the hash actually changed.
                     // If the hash was already '#comp', it won't trigger hashchange, so call directly.
                     if (window.location.hash.substring(1) === 'comp') {
                         handleNavigation();
                     }
                 });
                 // Set the raid selector to the initial currentRaidFolder value on load
                 raidSelector.value = currentRaidFolder;
             }
             handleNavigation(); // Initial load of content based on URL hash
        });

        // ============== LOGGING-FUNKTION (global verfügbar) ==============
        window.logHistory = async function(boss, assignment, player, editor) { // Global verfügbar gemacht
             await addDoc(historyCollectionRef, {
                boss: boss,
                assignment: assignment,
                player: player,
                editor: editor,
                timestamp: serverTimestamp()
            });
        };

        // ============== SEITEN-INITIALISIERUNG ==============
        function initializePage(pageId) {
            if (pageId === 'comp') initCompPage();
            else if (pageId === 'history') initHistoryPage();
            else initBossPage(pageId);

            // Diese werden am Ende von initBossPage aufgerufen, damit sie immer aktuell sind.
            // window.toggleSelectEditability(); // Global verfügbar machen
            // window.toggleCompEditability(); // Global verfügbar machen
        }

        // --- Logik für comp.html ---
        function initCompPage() {
            document.getElementById('import-btn')?.addEventListener('click', handleImportRoster);
            document.getElementById('add-player-btn')?.addEventListener('click', handleAddPlayer);
            document.getElementById('clear-roster-btn')?.addEventListener('click', handleClearRoster);

            currentRosterUnsubscribe = onSnapshot(rosterDocRef, (docSnap) => {
                const jsonInput = document.getElementById('json-input');
                if (docSnap.exists()) {
                    displayRoster(docSnap.data().roster || []);
                    if(jsonInput && jsonInput.value === ''){
                         jsonInput.value = docSnap.data().rawJson || '';
                    }
                } else {
                    displayRoster([]);
                }
            });
            window.toggleCompEditability(); // Aufruf hier
        }

        // --- Logik für history.html ---
        function initHistoryPage() {
            const q = query(historyCollectionRef, orderBy("timestamp", "desc"));
            const tableBody = document.getElementById('history-table-body');
            if (!tableBody) return;
            historyUnsubscribe = onSnapshot(q, (querySnapshot) => {
                tableBody.innerHTML = '';
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const row = tableBody.insertRow();
                    row.innerHTML = `
                        <td class="px-6 py-4">${data.boss || 'Allgemein'}</td>
                        <td class="px-6 py-4">${data.assignment}</td>
                        <td class="px-6 py-4 font-medium">${data.player}</td>
                        <td class="px-6 py-4">${data.editor}</td>
                        <td class="px-6 py-4">${data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleString('de-DE') : 'Unbekannt'}</td>
                    `;
                });
            });
        }

        // --- Logik für Boss-Seiten (Steinwache, Feng, etc.) ---
        function initBossPage(pageId) { // pageId ist der Boss-ID (z.B. "steinwache", "feng")
            // The pageId here will already be without the folder prefix, e.g., "steinwache"
            const assignmentsDocRef = doc(db, DATA_COLLECTION, "boss-" + pageId);

            // --- Logik für Größenumschaltung (von individuellen Boss-HTML-Dateien hierher verschoben) ---
            const sizeToggle = document.getElementById('size-toggle');
            if (sizeToggle) { // Prüfen, ob das Element auf der aktuellen Seite existiert
                sizeToggle.addEventListener('click', function(event) {
                    if (event.target.matches('.size-toggle-btn')) {
                        const selectedSize = event.target.dataset.size;
                        document.querySelectorAll('.size-toggle-btn').forEach(button => button.classList.remove('active-size-btn'));
                        event.target.classList.add('active-size-btn');
                        document.querySelectorAll('.tactic-content').forEach(content => {
                            // 'inline' für SPAN, 'block' für DIV/P/UL, um die Darstellung zu erhalten
                            content.style.display = content.dataset.size === selectedSize ? (content.tagName === 'SPAN' ? 'inline' : 'block') : 'none';
                        });
                    }
                });
                // Initialen aktiven Zustand und Anzeige basierend auf der Standard-25-Spieler-Ansicht für Boss-Seiten setzen
                const defaultSizeButton = document.querySelector(`#size-toggle button[data-size="25"]`);
                if (defaultSizeButton) {
                    defaultSizeButton.classList.add('active-size-btn');
                }
                document.querySelectorAll('.tactic-content').forEach(content => {
                    content.style.display = content.dataset.size === '25' ? (content.tagName === 'SPAN' ? 'inline' : 'block') : 'none';
                });
            }
            // --- Ende der Größenumschaltungslogik ---

            let rosterData = []; // Daten des Rosters, einmal geladen

            // Funktion zum Abrufen des Rosters
            async function fetchAndPopulateRoster() {
                const rosterSnap = await getDoc(rosterDocRef);
                rosterData = rosterSnap.exists() ? rosterSnap.data().roster || [] : [];
            }

            // Funktion zum Füllen von Dropdown-Optionen mit Spielernamen und Klassen
            function populateDropdownOptions(selectElement, players) {
                selectElement.innerHTML = '<option value="" data-color="#FFFFFF">-- Spieler wählen --</option>';
                players.forEach(player => {
                    const option = document.createElement('option');
                    const color = classColors[player.class.toUpperCase()] || '#FFFFFF';
                    option.value = player.name;
                    option.textContent = `${player.name} (${player.class})`; // Klasse zum Text hinzugefügt
                    option.style.color = color;
                    option.dataset.color = color;
                    selectElement.appendChild(option);
                });
            }

            // Handler für Änderungen in den Zuweisungs-Dropdowns
            async function handleAssignmentChange(event) {
                if (!window.isManager) return;
                const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
                const select = event.target;
                const assignmentId = select.dataset.assignmentId;
                const playerName = select.value || "Niemand";

                // Zuweisung in Firestore speichern, einschließlich Editor und Zeitstempel
                await setDoc(assignmentsDocRef, { [assignmentId]: { player: playerName, editor: currentManager, timestamp: serverTimestamp() } }, { merge: true });

                const bossName = pageId.charAt(0).toUpperCase() + pageId.slice(1);
                // Regex für CamelCase zu Leerzeichen und dann Trim
                const assignmentName = assignmentId.replace(pageId + '-', '').replace(/([A-Z])/g, ' $1').trim();
                window.logHistory(bossName, `Einteilung: ${assignmentName}`, playerName, currentManager); // Verwende globale logHistory
            }

            // Dropdowns initialisieren und Snapshot-Listener einrichten
            (async () => {
                await fetchAndPopulateRoster(); // Roster zuerst laden

                document.querySelectorAll('.assignment-select').forEach(select => {
                    select.addEventListener('change', handleAssignmentChange); // Change-Listener einmal hinzufügen

                    const assignmentId = select.dataset.assignmentId.toLowerCase();
                    let playersForDropdown = [];
                    if (assignmentId.includes('tank')) playersForDropdown = rosterData.filter(p => p.roles.includes('TANK'));
                    else if (assignmentId.includes('healer')) playersForDropdown = rosterData.filter(p => p.roles.includes('HEALER'));
                    else if (assignmentId.includes('dps') || assignmentId.includes('dd')) playersForDropdown = rosterData.filter(p => p.roles.includes('DPS'));
                    else playersForDropdown = rosterData;

                    populateDropdownOptions(select, playersForDropdown); // Optionen füllen
                });

                assignmentUnsubscribe = onSnapshot(assignmentsDocRef, (docSnap) => {
                    const assignments = docSnap.exists() ? docSnap.data() : {};
                    document.querySelectorAll('.assignment-select').forEach(select => {
                        const id = select.dataset.assignmentId;
                        const assignment = assignments[id]; // Das vollständige Assignment-Objekt holen
                        const assignedPlayerName = assignment ? assignment.player : "";

                        select.value = assignedPlayerName; // Wert setzen

                        // Farbe des Select-Elements basierend auf der ausgewählten Option setzen
                        const selectedOption = Array.from(select.options).find(o => o.value === assignedPlayerName);
                        select.style.color = selectedOption ? selectedOption.dataset.color : '#FFFFFF';
                    });
                    window.toggleSelectEditability(); // Bearbeitbarkeit nach Daten laden aktualisieren
                });

                window.toggleSelectEditability(); // Initialer Aufruf zur Einstellung der Bearbeitbarkeit
            })();
        }

        // ============== COMP LOGIK (HELFERFUNKTIONEN, global verfügbar) ==============
        function getPlayerInfoFromEntry(playerEntry) {
            let playerClass = playerEntry.class ? playerEntry.class.toUpperCase() : 'UNKNOWN';
            if (playerClass === 'DK') playerClass = 'DEATHKNIGHT';
            let spec = playerEntry.spec;
            const specToClassMap = { 'Guardian': 'DRUID', 'Blood_Tank': 'DEATHKNIGHT', 'Protection': 'WARRIOR', 'Protection1': 'PALADIN', 'Brewmaster': 'MONK' };
            if ((playerClass === 'TANK' || specToClassMap[spec]) && spec) {
                const classFromSpec = specToClassMap[spec];
                if (classFromSpec) playerClass = classFromSpec;
            }
            const tankSpecs = ['Guardian', 'Blood_Tank', 'Protection', 'Protection1', 'Brewmaster'];
            const healerSpecs = ['Restoration', 'Restoration1', 'Discipline', 'Holy', 'Holy1', 'Mistweaver'];
            let role = 'DPS';
            if (tankSpecs.includes(spec)) role = 'TANK';
            else if (healerSpecs.includes(spec)) role = 'HEALER';
            return { name: playerEntry.name, class: playerClass, roles: [role], id: crypto.randomUUID() };
        }

        function displayRoster(roster) {
            const lists = { TANK: document.getElementById('tanks-list'), HEALER: document.getElementById('healers-list'), DPS: document.getElementById('dps-list') };
            if (!lists.TANK) return;
            Object.values(lists).forEach(list => list.innerHTML = '');
            roster.forEach(player => {
                const playerElement = createPlayerElement(player);
                if (player.roles.includes('TANK')) lists.TANK.appendChild(playerElement.cloneNode(true));
                if (player.roles.includes('HEALER')) lists.HEALER.appendChild(playerElement.cloneNode(true));
                if (player.roles.includes('DPS')) lists.DPS.appendChild(playerElement.cloneNode(true));
            });
            roster.forEach(player => {
                 document.querySelectorAll(`[data-player-id="${player.id}"]`).forEach(element => {
                    const nameInput = element.querySelector('.editable-name');
                    nameInput?.addEventListener('blur', (e) => handlePlayerUpdate(e, player.id, 'name'));
                    const classSelect = element.querySelector('.editable-class-select');
                    classSelect?.addEventListener('change', (e) => handlePlayerUpdate(e, player.id, 'class'));
                    element.querySelectorAll('.role-btn').forEach(btn => btn.addEventListener('click', () => togglePlayerRole(player.id, btn.dataset.role)));
                });
            });
            ['TANK', 'HEALER', 'DPS'].forEach(role => {
                if(lists[role].children.length === 0) lists[role].innerHTML = `<p class="text-gray-500">Keine ${role.toLowerCase()}s zugewiesen.</p>`;
            });
            window.toggleCompEditability();
        }

        function createPlayerElement(player) {
            const playerDiv = document.createElement('div');
            playerDiv.className = 'flex justify-between items-center';
            playerDiv.dataset.playerId = player.id;
            playerDiv.innerHTML = `
                <div class="player-details">
                    <input type="text" value="${player.name}" class="editable-name" style="color: ${classColors[player.class.toUpperCase()] || '#FFFFFF'};" ${!window.isManager ? 'disabled' : ''}>
                    <select class="editable-class-select" ${!window.isManager ? 'disabled' : ''}>
                        ${wowClasses.map(c => `<option value="${c}" ${player.class === c ? 'selected' : ''}>${c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()}</option>`).join('')}
                    </select>
                </div>
                <div class="flex gap-1">
                    ${['TANK', 'HEALER', 'DPS'].map(role => `<button class="role-btn role-${role.toLowerCase()} ${player.roles.includes(role) ? 'active' : ''}" data-role="${role}" ${!window.isManager ? 'disabled' : ''}>${role.charAt(0)}</button>`).join('')}
                </div>`;
            return playerDiv;
        }

        window.toggleSelectEditability = function() { // Global verfügbar gemacht
            document.querySelectorAll('.assignment-select').forEach(el => { el.disabled = !window.isManager; });
        };
        window.toggleCompEditability = function() { // Global verfügbar gemacht
            if(!document.getElementById('import-btn')) return;
            document.querySelectorAll('#import-btn, #add-player-btn, #clear-roster-btn, .editable-name, .editable-class-select, .role-btn').forEach(el => { el.disabled = !window.isManager; });
        };

        async function handlePlayerUpdate(event, playerId, field) {
            if (!window.isManager) return;
            const docSnap = await getDoc(rosterDocRef);
            if (!docSnap.exists()) return;

            const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
            let roster = docSnap.data().roster || [];
            const playerIndex = roster.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return;

            const oldPlayer = {...roster[playerIndex]};
            const newValue = event.target.value;
            roster[playerIndex][field] = newValue;

            await updateDoc(rosterDocRef, { roster: roster });

            const changeText = field === 'name' ? `umbenannt in ${newValue}` : `Klasse geändert zu ${newValue}`;
            window.logHistory('Roster', `${oldPlayer.name} ${changeText}`, '', currentManager);
        }

        async function togglePlayerRole(playerId, roleToToggle) {
            if (!window.isManager) return;
            const docSnap = await getDoc(rosterDocRef);
            if (!docSnap.exists()) return;

            const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
            let roster = docSnap.data().roster || [];
            const player = roster.find(p => p.id === playerId);
            if (!player) return;

            let changeText = '';
            const roleIndex = player.roles.indexOf(roleToToggle);
            if (roleIndex > -1) {
                if(player.roles.length > 1) {
                    player.roles.splice(roleIndex, 1);
                    changeText = `Rolle ${roleToToggle} entfernt`;
                }
            } else {
                player.roles.push(roleToToggle);
                changeText = `Rolle ${roleToToggle} hinzugefügt`;
            }

            if(changeText) {
                await updateDoc(rosterDocRef, { roster: roster });
                window.logHistory('Roster', changeText, player.name, currentManager);
            }
        }

        async function handleImportRoster() {
            if (!window.isManager) return;
            const jsonString = document.getElementById('json-input').value;
            if (!jsonString) {
                window.showModal("Bitte JSON einfügen.");
                return;
            }
            try {
                const data = JSON.parse(jsonString);
                if (!data.raidDrop || !Array.isArray(data.raidDrop)) throw new Error("Ungültiges JSON: 'raidDrop' Array fehlt oder ist ungültig.");
                const newRoster = data.raidDrop.map(getPlayerInfoFromEntry);
                await setDoc(rosterDocRef, { roster: newRoster, rawJson: jsonString });

                const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
                window.logHistory('Roster', `Importiert`, `${newRoster.length} Spieler`, currentManager);
                window.showModal(`Roster mit ${newRoster.length} Spielern importiert!`);
            } catch (error) {
                window.showModal("Fehler beim Verarbeiten des JSON: " + error.message);
            }
        }

        async function handleAddPlayer() {
            if (!window.isManager) return;
            const name = prompt("Name des neuen Spielers:", "NeuerSpieler"); // Keeping prompt for input simplicity
            if (!name) return;

            const newPlayer = { id: crypto.randomUUID(), name: name, class: 'WARRIOR', roles: ['DPS'] };
            const docSnap = await getDoc(rosterDocRef);
            const roster = docSnap.exists() ? docSnap.data().roster || [] : [];
            roster.push(newPlayer);

            await setDoc(rosterDocRef, { roster: roster }, { merge: true });

            const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
            window.logHistory('Roster', `Spieler hinzugefügt`, name, currentManager);
            window.showModal(`Spieler '${name}' wurde hinzugefügt.`);
        }

        async function handleClearRoster() {
            if (!window.isManager) return;
            const confirmed = await window.showModal("Sollen wirklich alle Spieler aus dem Roster entfernt werden?", true);
            if (confirmed) {
                await setDoc(rosterDocRef, { roster: [], rawJson: '' });
                document.getElementById('json-input').value = '';
                const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
                window.logHistory('Roster', 'Geleert', '', currentManager);
                window.showModal("Roster wurde geleert.");
            }
        }
    </script>
</body>
</html>
