<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raid Sheet - PÄNIK</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
    /* cinzel-regular - latin */
    @font-face {
      font-display: swap;
      font-family: 'Cinzel';
      font-style: normal;
      font-weight: 400;
      src: url('/static/fonts/cinzel-v25-latin-regular.woff2') format('woff2');
    }
    /* cinzel-700 - latin */
    @font-face {
      font-display: swap;
      font-family: 'Cinzel';
      font-style: normal;
      font-weight: 700;
      src: url('/static/fonts/cinzel-v25-latin-700.woff2') format('woff2');
    }
    /* inter-regular - latin */
    @font-face {
      font-display: swap;
      font-family: 'Inter';
      font-style: normal;
      font-weight: 400;
      src: url('/static/fonts/inter-v19-latin-regular.woff2') format('woff2');
    }
    /* inter-600 - latin */
    @font-face {
      font-display: swap;
      font-family: 'Inter';
      font-style: normal;
      font-weight: 600;
      src: url('/static/fonts/inter-v19-latin-600.woff2') format('woff2');
    }
    /* inter-700 - latin */
    @font-face {
      font-display: swap;
      font-family: 'Inter';
      font-style: normal;
      font-weight: 700;
      src: url('/static/fonts/inter-v19-latin-700.woff2') format('woff2');
    }

    /* --- ENDE DES NEUEN CODES --- */


    /* FINALES "MISTS OF PANDARIA" THEMA MIT ALLEN FEHLERBEHEBUNGEN */
    :root {
        --color-gold: #fcd34d;
        /* ... dein restliches CSS ... */
    }
    /* ... */

        /* FINALES "MISTS OF PANDARIA" THEMA MIT ALLEN FEHLERBEHEBUNGEN */
        :root {
            --color-gold: #fcd34d;
            --color-jade: #5eead4;
            --color-parchment: #f5f2e8;
            --color-dark-green-bg: rgba(25, 42, 35, 0.92);
            --color-medium-green-bg: rgba(36, 61, 51, 0.88);
            --color-dark-text: #102a23;
            --color-gold-border: rgba(204, 163, 76, 0.4);
            --color-gold-border-light: rgba(204, 163, 76, 0.2);
        }
        body { 
            font-family: 'Inter', sans-serif;
            color: var(--color-parchment);
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Cinzel', serif;
            letter-spacing: 0.05em;
        }
        .main-container {
            background-color: var(--color-dark-green-bg);
            border: 1px solid var(--color-gold-border);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
        /* Diese Klassen überschreiben die alten, falls sie im dynamischen HTML noch vorkommen */
        .bg-slate-850, .bg-slate-750 {
            background-color: var(--color-medium-green-bg) !important;
            border: 1px solid var(--color-gold-border-light) !important;
        }
        .text-blue-450 { color: var(--color-gold) !important; }
        .border-slate-650 { border-color: var(--color-gold-border) !important; }
        .text-gold { color: var(--color-gold); }

        .nav-link { 
            background-color: rgba(74, 115, 95, 0.6); 
            border: 1px solid var(--color-gold-border-light);
            transition: all 0.2s ease-in-out;
            color: var(--color-parchment);
            font-family: 'Cinzel', serif;
            font-weight: bold;
        }
        .nav-link:hover {
            background-color: rgba(87, 135, 111, 0.8);
            border-color: var(--color-gold-border);
        }
        .nav-link.active-tab { 
            background-color: var(--color-jade);
            color: var(--color-dark-text) !important;
            border-color: #99f6e4;
            box-shadow: 0 0 15px rgba(94, 234, 212, 0.4);
            transform: translateY(-2px);
        }
        
        button, .btn { font-family: 'Cinzel', serif; font-weight: bold; transition: all 0.2s ease-in-out; }
        button:disabled { opacity: 0.5 !important; cursor: not-allowed !important; }

        .bg-blue-600 { background-color: #ca8a04 !important; color: var(--color-dark-text) !important; }
        .bg-blue-600:hover { background-color: #eab308 !important; }
        .bg-green-600, .bg-green-700 { background-color: #15803d !important; color: var(--color-parchment) !important; }
        .bg-green-600:hover, .bg-green-700:hover { background-color: #16a34a !important; }
        .bg-red-700, .bg-red-800, .cancel-btn { background-color: #b91c1c !important; color: var(--color-parchment) !important; }
        .bg-red-700:hover, .bg-red-800:hover, .cancel-btn:hover { background-color: #dc2626 !important; }

        #raid-selector, .assignment-select {
            background-color: rgba(10, 20, 15, 0.7) !important;
            border: 1px solid var(--color-gold-border) !important;
            color: var(--color-parchment);
            border-radius: 0.25rem;
        }
        
        .editable-name {
            background-color: transparent !important;
            border: 1px solid transparent !important;
            border-radius: 4px;
            padding: 2px 4px;
        }
        .editable-name:hover:not(:disabled), .editable-name:focus {
             background-color: rgba(10, 20, 15, 0.7) !important;
             border: 1px solid var(--color-gold-border) !important;
        }
        .editable-class-select {
             background-color: rgba(10, 20, 15, 0.7) !important;
             border: 1px solid var(--color-gold-border) !important;
             color: var(--color-parchment) !important;
        }
        #json-input, #loot-json-input { background-color: rgba(10, 20, 15, 0.7) !important; border: 1px solid var(--color-gold-border) !important; color: #a0aec0 !important; }

        #background-video { position: fixed; right: 0; bottom: 0; min-width: 100%; min-height: 100%; z-index: -100; object-fit: cover; filter: brightness(0.4); }
        .content-wrapper { position: relative; z-index: 2; }
        
        /* KORREKTUR: Login Modal Overlay Styling */
        .login-modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .login-modal-content {
            background-color: var(--color-dark-green-bg);
            border: 1px solid var(--color-gold-border);
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            text-align: center;
            width: 90%;
            max-width: 400px;
        }
        .login-modal-content h3 { font-size: 1.5rem; margin-bottom: 1.5rem; color: var(--color-gold); }
        .login-modal-content input { background-color: rgba(10, 20, 15, 0.7) !important; border: 1px solid var(--color-gold-border) !important; color: var(--color-parchment) !important; border-radius: 0.25rem; padding: 0.5rem; width: 100%; margin-bottom: 1rem; }
        .login-modal-buttons { display: flex; justify-content: center; gap: 1rem; margin-top: 1.5rem; }

		/* KORREKTUR: Roster-Button Farben und Hervorhebung */
		.role-btn { 
			border: 2px solid transparent; /* Transparenter Rand, um Layout-Sprünge zu vermeiden */
			background-color: rgba(0,0,0,0.2); 
			color: rgba(204, 163, 76, 0.7); 
			opacity: 0.7; 
			border-radius: 6px;
		}
		.role-btn:not(:disabled):hover { 
			opacity: 1;
			border-color: #ca8a04;
		}
		.role-btn.active { 
			opacity: 1; 
			transform: scale(1.1); /* Aktives Icon leicht vergrößern */
			background-color: transparent !important; /* Sicherstellen, dass der Hintergrund weg ist */
		}
		.role-btn.role-tank.active { 
			border-color: #60a5fa !important;
			box-shadow: 0 0 8px #60a5fa;
		}
		.role-btn.role-healer.active { 
			border-color: #34d399 !important; 
			box-shadow: 0 0 8px #34d399;
		}
		.role-btn.role-dps.active { 
			border-color: #f87171 !important; 
			box-shadow: 0 0 8px #f87171;
		}

        /* Originale Klassen zur Sicherheit beibehalten und überschreiben */
        .text-gray-200, .text-white { color: var(--color-parchment); }
        .text-gray-400 { color: #a0aec0; }
        .buff-tooltip { position: absolute; z-index: 100; background-color: #1a202c; border: 1px solid #4a5568; padding: 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; color: #e2e8f0; white-space: nowrap; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
    /* KORREKTUR: Fehlende Stile für das allgemeine Modal-Fenster */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background-color: var(--color-dark-green-bg);
            border: 1px solid var(--color-gold-border);
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            text-align: center;
            width: 90%;
            max-width: 450px;
        }
        .modal-content h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--color-gold);
        }
        .modal-content p {
            margin-bottom: 1.5rem;
            font-family: 'Inter', sans-serif;
            color: var(--color-parchment);
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        .modal-buttons button {
            padding: 0.5rem 1.5rem;
            border-radius: 0.25rem;
            color: var(--color-dark-text) !important;
            background-color: #ca8a04 !important;
        }
        .modal-buttons button:hover {
            background-color: #eab308 !important;
        }
        .modal-buttons .cancel-btn {
            background-color: #b91c1c !important;
            color: var(--color-parchment) !important;
        }
        .modal-buttons .cancel-btn:hover {
            background-color: #dc2626 !important;
        }

		.player-details {
			display: flex;
			flex-direction: column; /* Stellt Name und Klasse untereinander dar */
			align-items: flex-start;
			gap: 0.25rem;
			min-width: 0; 
		}
		.editable-name, .editable-class-select {
			width: 160px; /* Gibt beiden eine feste Breite für einheitliches Aussehen */
		}
		@media (max-width: 1200px) {
			.player-row-container {
				flex-direction: column; /* Stellt Details und Symbole untereinander dar */
				align-items: flex-start; /* Richtet alles linksbündig aus */
				gap: 0.75rem; /* Abstand zwischen den Elementen */
				padding-bottom: 0.75rem;
				border-bottom: 1px solid var(--color-gold-border-light);
			}
			.player-row-container:last-child {
				border-bottom: none;
			}
		}
		.border-gold-faded {
			border-color: var(--color-gold-border);
		}
		/* Stile für responsive YouTube-Videos */
		.video-container {
			position: relative;
			overflow: hidden;
			width: 100%;
			padding-top: 56.25%; /* 16:9 Seitenverhältnis */
			border: 1px solid var(--color-gold-border);
			border-radius: 0.5rem;
		}
		
		.video-container iframe {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
		}
	</style>
</head>
<body>
<body class="pt-4">
<video autoplay muted loop playsinline id="background-video">
    <source src="static/background.webm" type="video/webm">
</video>
<div class="content-wrapper">
    <div class="max-w-7xl mx-auto main-container p-6 rounded-lg shadow-2xl relative">
        <div id="auth-section"></div>
        <header class="text-center pb-4 mb-6 border-b border-slate-650">
            <h1 class="text-5xl font-bold text-gold">P Ä N I K Raidsheet</h1>
             <div class="flex justify-center items-center gap-2 mt-2">
                <p class="text-lg text-gray-400">Strategien und Einteilungen</p>
                <div id="presence-indicator" class="flex items-center gap-2 text-sm text-gray-400"></div>
            </div>
        </header>

        <h2 class="text-2xl font-semibold text-center text-blue-450 mb-4">Navigation</h2>
        <div class="flex justify-center mb-4">
            <label for="raid-selector" class="sr-only">Raid auswählen</label>
            <select id="raid-selector" class="bg-slate-850 text-gray-200 p-2 rounded-md border border-slate-650 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="mogushan" selected>Mogu'shangewölbe</option>
                <option value="heartoffear">Das Herz der Angst</option>
                <option value="terraceofendlessspring">Terrasse des Endlosen Frühlings</option>
                <option value="throneofthunder">Der Thron des Donners</option>
                <option value="siegeoforgrimmar">Schlacht um Orgrimmar</option>
            </select>
        </div>
        <nav id="main-nav" class="flex flex-wrap justify-center gap-2 mb-4"></nav>
		<nav id="boss-nav" class="flex flex-wrap justify-center gap-2 mb-8"></nav>
            </nav>

        <main id="content-container">
            </main>

    </div>
			
<footer class="text-center text-sm text-gray-400 py-4 font-sans space-y-1">
  <p>© 2025 PÄNIK Raidtools – erstellt von Marcel</p>
  <p>Veröffentlicht unter <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.de" target="_blank" rel="noopener noreferrer" class="hover:underline">CC BY-NC-SA 4.0</a></p>
</footer>
		

    <div id="login-modal-overlay" class="login-modal-overlay hidden">
        <div class="login-modal-content">
            <h3>Gildenrat-Login</h3>
            <input type="text" id="login-username" placeholder="Benutzername" required>
            <input type="password" id="login-password" placeholder="Passwort" required>
            <div class="login-modal-buttons">
                <button id="login-modal-cancel-btn" class="cancel-btn">Abbrechen</button>
                <button id="login-modal-submit-btn">Login</button>
            </div>
        </div>
    </div>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc, getDoc, serverTimestamp, query, orderBy, addDoc, updateDoc, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
		
        // ============== INITIALISIERUNG & GLOBALE VARIABLEN ==============
        const firebaseConfig = {
            apiKey: "AIzaSyBmqCCIOKq0OQOTEgJJ7Lj8CYlLihVBVSU",
            authDomain: "panik-raid.firebaseapp.com",
            projectId: "panik-raid",
            storageBucket: "panik-raid.appspot.com",
            messagingSenderId: "120578974053",
            appId: "1:120578974053:web:927a81dccbb4b33f86c18c"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        window.isManager = false;
        let currentRosterUnsubscribe = null;
        let historyUnsubscribe = null;
        let assignmentUnsubscribe = null;
		let lootDatesUnsubscribe = null;
        let selectedLootDateUnsubscribe = null;
        let heartbeatIntervalId = null;
		let allLootDocuments = [];
		let playerSummaryState = {};
		let summarySortState = { column: 'total', direction: 'desc' };

        const DATA_COLLECTION = "raid-tool-data";
        const HISTORY_COLLECTION = "raid-tool-history";
        const USER_PROFILES_COLLECTION = "user_profiles";
		const LOOT_COLLECTION = "raid-tool-loot";

        const raidData = {
            mogushan: {
                name: "Mogu'shangewölbe",
                bosses: [
                    { id: 'steinwache', name: 'Die Steinwache' },
                    { id: 'feng', name: 'Feng der Verfluchte' },
                    { id: 'garajal', name: 'Gara\'jal der Geisterbinder' },
                    { id: 'geisterkoenige', name: 'Die Geisterkönige' },
                    { id: 'elegon', name: 'Elegon' },
                    { id: 'wille', name: 'Wille des Kaisers' }
                ]
            },
            heartoffear: {
                name: "Das Herz der Angst",
                bosses: [
                    { id: 'zorlok', name: 'Kaiserlicher Wesir Zor\'lok' },
                    { id: 'tayak', name: 'Klingenfürst Ta\'yak' },
                    { id: 'garalon', name: 'Garalon' },
                    { id: 'meljarak', name: 'Windfürst Mel\'jarak' },
                    { id: 'unsof', name: 'Bernformer Un\'sok' },
                    { id: 'shekzeer', name: 'Großkaiserin Shek\'zeer' }
                ]
            },
            terraceofendlessspring: {
                name: "Terrasse des Endlosen Frühlings",
                bosses: [
                    { id: 'protectors', name: 'Beschützer des Endlosen' },
                    { id: 'tsulong', name: 'Tsulong' },
                    { id: 'lei-shi', name: 'Lei Shi' },
                    { id: 'sha-of-fear', name: 'Sha der Angst' }
                ]
            },
            throneofthunder: {
                name: "Der Thron des Donners",
                bosses: [
                    { id: 'jinrokh', name: 'Jin\'rokh der Zerstörer' },
                    { id: 'horridon', name: 'Horridon' },
                    { id: 'council', name: 'Rat der Ältesten' },
                    { id: 'tortos', name: 'Tortos' },
                    { id: 'megaira', name: 'Megaira' },
                    { id: 'ji-kun', name: 'Ji-Kun' },
                    { id: 'durumu', name: 'Durumu der Vergessene' },
                    { id: 'primordius', name: 'Primordius' },
                    { id: 'dark-animus', name: 'Dunkler Animus' },
                    { id: 'iron-qon', name: 'Eiserner Qon' },
                    { id: 'twin-consorts', name: 'Zwillingskonkubinen' },
                    { id: 'lei-shen', name: 'Lei Shen' },
                    { id: 'ra-den', name: 'Ra-den' }
                ]
            },
            siegeoforgrimmar: {
                name: "Schlacht um Orgrimmar",
                bosses: [
                    { id: 'immerseus', name: 'Immerseus' },
                    { id: 'fallen-protectors', name: 'Die gefallenen Beschützer' },
                    { id: 'norushen', name: 'Norushen' },
                    { id: 'sha-of-pride', name: 'Sha des Stolzes' },
                    { id: 'galakras', name: 'Galakras' },
                    { id: 'iron-juggernaut', name: 'Eiserner Koloss' },
                    { id: 'korkron-dark-shamans', name: 'Dunkelschamanen der Kor\'kron' },
                    { id: 'general-nazgrim', name: 'General Nazgrim' },
                    { id: 'malkorok', name: 'Malkorok' },
                    { id: 'spoils-of-pandaria', name: 'Die Schätze Pandarias' },
                    { id: 'thok', name: 'Thok der Blutrünstige' },
                    { id: 'siegecrafter', name: 'Belagerungsingenieur Rußschmied' },
                    { id: 'paragons', name: 'Die Getreuen der Klaxxi' },
                    { id: 'garrosh', name: 'Garrosh Höllschrei' }
                ]
            }
        };

        window.classColors = { 'DEATHKNIGHT': '#C41F3B', 'DK': '#C41F3B', 'DRUID': '#FF7D0A', 'HUNTER': '#AAD372', 'MAGE': '#3FC7EB', 'MONK': '#00FF96', 'PALADIN': '#F48CBA', 'PRIEST': '#FFFFFF', 'ROGUE': '#FFF569', 'SHAMAN': '#0070DD', 'WARLOCK': '#8788EE', 'WARRIOR': '#C69B6D', 'TANK': '#A3A3A3' };
        const wowClasses = ['WARRIOR', 'PALADIN', 'HUNTER', 'ROGUE', 'PRIEST', 'DEATHKNIGHT', 'SHAMAN', 'MAGE', 'WARLOCK', 'MONK', 'DRUID'];
        const rosterDocRef = doc(db, DATA_COLLECTION, "currentRoster");
        const historyCollectionRef = collection(db, HISTORY_COLLECTION);
        const userProfilesCollectionRef = collection(db, USER_PROFILES_COLLECTION);
		const lootCollectionRef = collection(db, LOOT_COLLECTION);

        // ============== MODAL-FUNKTION (global verfügbar) ==============
        window.showModal = function(message, isConfirm = false) {
            return new Promise((resolve) => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.innerHTML = `
                    <div class="modal-content">
                        <h3>Nachricht</h3>
                        <p>${message}</p>
                        <div class="modal-buttons">
                            ${isConfirm ? `<button id="modal-cancel-btn" class="cancel-btn">Abbrechen</button>` : ''}
                            <button id="modal-ok-btn">OK</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('modal-ok-btn').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });

                if (isConfirm) {
                    document.getElementById('modal-cancel-btn').addEventListener('click', () => {
                        document.body.removeChild(modalOverlay);
                        resolve(false);
                    });
                }
            });
        };
        
        // ============== LOGIN MODAL FUNKTION ==============
        function showLoginModal() {
             return new Promise((resolve) => {
                const loginModalOverlay = document.getElementById('login-modal-overlay');
                const loginUsernameInput = document.getElementById('login-username');
                const loginPasswordInput = document.getElementById('login-password');
                const loginSubmitBtn = document.getElementById('login-modal-submit-btn');
                const loginCancelBtn = document.getElementById('login-modal-cancel-btn');

                loginUsernameInput.value = '';
                loginPasswordInput.value = '';
                loginModalOverlay.classList.remove('hidden');

                const handleSubmit = async () => {
                    const username = loginUsernameInput.value;
                    const password = loginPasswordInput.value;

                    if (!username || !password) {
                        window.showModal("Bitte Benutzername und Passwort eingeben.");
                        return;
                    }

                    try {
                        const q = query(userProfilesCollectionRef, where("username", "==", username));
                        const querySnapshot = await getDocs(q);

                        if (querySnapshot.empty) {
                            window.showModal("Benutzername nicht gefunden.");
                            return;
                        }

                        const userProfile = querySnapshot.docs[0].data();
                        const email = userProfile.email;
                        const isManagerFlag = userProfile.isManager || false;
                        
                        const userCredential = await signInWithEmailAndPassword(auth, email, password);

                        if (isManagerFlag) {
                            sessionStorage.setItem('currentManager', username);
                            loginModalOverlay.classList.add('hidden');
                            location.reload();
                            resolve(true);
                        } else {
                            await signOut(auth);
                            window.showModal("Dieses Konto ist keinem Gildenrat-Status zugeordnet.");
                            resolve(false);
                        }
                    } catch (error) {
                        console.error("Login-Fehler:", error);
                        let errorMessage = "Unbekannter Login-Fehler.";
                        if (error.code === 'auth/wrong-password' || error.code === 'auth/user-not-found' || error.code === 'auth/invalid-credential') {
                            errorMessage = "Falscher Benutzername oder falsches Passwort.";
                        } else if (error.code === 'auth/invalid-email') {
                            errorMessage = "Ungültiges E-Mail-Format (interner Fehler).";
                        }
                        window.showModal(errorMessage);
                        resolve(false);
                    }
                };

                const handleCancel = () => {
                    loginModalOverlay.classList.add('hidden');
                    resolve(false);
                };
				const handleKeydown = (event) => {
								if (event.key === 'Enter') {
									event.preventDefault();
									handleSubmit();
								}
							};
				loginUsernameInput.addEventListener('keydown', handleKeydown);
				loginPasswordInput.addEventListener('keydown', handleKeydown);
                loginSubmitBtn.addEventListener('click', handleSubmit);
                loginCancelBtn.addEventListener('click', handleCancel);

                loginModalOverlay.addEventListener('click', function clickOutside(event) {
                    if (event.target === loginModalOverlay) {
                        handleCancel();
                    }
                });
            });
        }
        
        // ============== AUTHENTIFIZIERUNG & PRESENCE ==============
        async function setupAuthUI() {
            const authSection = document.getElementById('auth-section');
            const currentManagerUsername = sessionStorage.getItem('currentManager');

            if (currentManagerUsername) {
                const q = query(userProfilesCollectionRef, where("username", "==", currentManagerUsername));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const userProfile = querySnapshot.docs[0].data();
                    if (userProfile.isManager) {
                        window.isManager = true;
                        authSection.innerHTML = `<span class="text-white">Angemeldet als: <strong>${currentManagerUsername}</strong></span><button id="logout-btn" class="ml-2 bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-md text-sm">Logout</button>`;
                        document.getElementById('logout-btn').addEventListener('click', async () => {
                            await signOut(auth);
                            sessionStorage.removeItem('currentManager');
                            location.hash = '';
                            location.reload();
                        });
                        return;
                    }
                }
                sessionStorage.removeItem('currentManager');
            }

            window.isManager = false;
            authSection.innerHTML = `<button id="login-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-md text-sm">Gildenrat-Login</button>`;
            document.getElementById('login-btn').addEventListener('click', showLoginModal);
        }

        onAuthStateChanged(auth, user => {
            const presenceIndicator = document.getElementById('presence-indicator');
            if (heartbeatIntervalId) clearInterval(heartbeatIntervalId);

            if (!user) {
                signInAnonymously(auth).catch(e => console.error("Anonymer Login-Fehler:", e));
                presenceIndicator.innerHTML = `<div class="w-3 h-3 bg-gray-500 rounded-full"></div><span>0</span> Online`;
                return;
            }

            const userStatusRef = doc(db, "presence", user.uid);
            const updatePresenceTimestamp = () => {
                setDoc(userStatusRef, { online: true, last_changed: serverTimestamp() }, { merge: true });
            };
            updatePresenceTimestamp();
            heartbeatIntervalId = setInterval(updatePresenceTimestamp, 5 * 60 * 1000);

            onSnapshot(collection(db, "presence"), snap => {
                const nowInSeconds = Date.now() / 1000;
                const onlineUsersCount = snap.docs.filter(doc => {
                    const data = doc.data();
                    return data.online && data.last_changed && (nowInSeconds - data.last_changed.seconds < 360);
                }).length;
                presenceIndicator.innerHTML = `<div class="w-3 h-3 bg-green-400 rounded-full animate-pulse"></div><span>${onlineUsersCount}</span> Online`;
            });
        });

        // ============== NAVIGATION & CONTENT LOADING ==============
        const contentContainer = document.getElementById('content-container');
        const bossNav = document.getElementById('boss-nav');
        const raidSelector = document.getElementById('raid-selector');

		function updateBossNav(raidId) {
            const mainNav = document.getElementById('main-nav');
            const bossNav = document.getElementById('boss-nav');
            const raid = raidData[raidId];

            // 1. Die Hauptnavigation - Padding (py-2 px-4) wieder hinzugefügt
            const mainNavHTML = `
                <a href="#comp" data-page-id="comp" class="nav-link bg-green-700 hover:bg-green-600 rounded-md py-2 px-4">Übersicht & Comp</a>
                <a href="#loot" data-page-id="loot" class="nav-link rounded-md py-2 px-4" style="background-color: #7c3aed;">Lootverlauf</a>
                <a href="#history" data-page-id="history" class="nav-link bg-indigo-600 hover:bg-indigo-500 rounded-md py-2 px-4">Änderungsverlauf</a>
            `;
            mainNav.innerHTML = mainNavHTML;

            // 2. Die Boss-Navigation - Padding (py-2 px-4) wieder hinzugefügt
            if (!raid || !raid.bosses) {
                bossNav.innerHTML = '';
                return;
            }
            
            const bossNavHTML = raid.bosses.map(boss => {
                const pageId = `${raidId}/${boss.id}`;
                // Hier wurde 'py-2 px-4' hinzugefügt
                return `<a href="#${pageId}" data-page-id="${pageId}" class="nav-link rounded-md py-2 px-4">${boss.name}</a>`;
            }).join('');

            bossNav.innerHTML = bossNavHTML;
        }

        async function loadContent(pageId) {
            if (currentRosterUnsubscribe) { currentRosterUnsubscribe(); currentRosterUnsubscribe = null; }
            if (historyUnsubscribe) { historyUnsubscribe(); historyUnsubscribe = null; }
            if (assignmentUnsubscribe) { assignmentUnsubscribe(); assignmentUnsubscribe = null; }
			if (lootDatesUnsubscribe) { lootDatesUnsubscribe(); lootDatesUnsubscribe = null; }
			if (selectedLootDateUnsubscribe) { selectedLootDateUnsubscribe(); selectedLootDateUnsubscribe = null; }

            const filePath = pageId.includes('/') ? `${pageId}.html` : `${pageId}.html`;

            try {
                const response = await fetch(filePath);
                if (!response.ok) throw new Error(`Seite ${filePath} nicht gefunden.`);
                contentContainer.innerHTML = await response.text();
                const actualPageIdForInit = pageId.includes('/') ? pageId.split('/')[1] : pageId;
                initializePage(actualPageIdForInit);
            } catch (error) {
                console.error("Fehler beim Laden des Inhalts:", error);
                contentContainer.innerHTML = `<div class="text-center p-8 bg-slate-850 rounded-lg"><h2 class="text-2xl font-semibold text-yellow-400">Inhalt nicht gefunden</h2><p class="mt-2 text-gray-400">Für diesen Boss wurde noch keine Seite angelegt. Bitte erstelle die Datei <code>${filePath}</code>.</p></div>`;
            }
        }

        function renderCurrentState() {
            const currentRaidId = raidSelector.value;
            updateBossNav(currentRaidId);

            let pageId = window.location.hash.substring(1) || 'comp';
            
            if (pageId.includes('/')) {
                const raidOfPage = pageId.split('/')[0];
                if (raidData[raidOfPage] && raidSelector.value !== raidOfPage) {
                    raidSelector.value = raidOfPage;
                    updateBossNav(raidOfPage);
                }
            }
            
            loadContent(pageId);

            document.querySelectorAll('#main-nav .nav-link, #boss-nav .nav-link').forEach(link => {
                link.classList.toggle('active-tab', link.dataset.pageId === pageId);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            setupAuthUI();

            raidSelector.addEventListener('change', () => {
                if (window.location.hash === '#comp' || window.location.hash === '') {
                    renderCurrentState();
                } else {
                    window.location.hash = '#comp';
                }
            });

            window.addEventListener('hashchange', renderCurrentState);
            
            renderCurrentState();
        });
        
        // ============== LOGGING-FUNKTION ==============
        window.logHistory = async function(boss, assignment, player, editor) {
             await addDoc(historyCollectionRef, {
                boss: boss,
                assignment: assignment,
                player: player,
                editor: editor,
                timestamp: serverTimestamp()
            });
        };

        // ============== SEITEN-INITIALISIERUNG ==============
		function initializePage(pageId) {
			if (pageId === 'comp') {
				initCompPage();
			} else if (pageId === 'history') {
				initHistoryPage();
			} else if (pageId === 'loot') {
				initLootPage();
			} else if (pageId === 'impressum' || pageId === 'datenschutz') {
				// No JS needed
			} else {
				initBossPage(pageId);
			}
		}

        // --- Logik für comp.html ---
        function initCompPage() {
            document.getElementById('import-btn')?.addEventListener('click', handleImportRoster);
            document.getElementById('add-player-btn')?.addEventListener('click', handleAddPlayer);
            document.getElementById('clear-roster-btn')?.addEventListener('click', handleClearRoster);

            currentRosterUnsubscribe = onSnapshot(rosterDocRef, (docSnap) => {
                const jsonInput = document.getElementById('json-input');
                const currentRosterData = docSnap.exists() ? docSnap.data().roster || [] : [];
                displayRoster(currentRosterData);
                if (window.updateRaidBuffsDisplay) {
                    window.updateRaidBuffsDisplay(currentRosterData);
                }
                if(jsonInput && jsonInput.value === ''){
                     jsonInput.value = docSnap.data().rawJson || '';
                }
            });
            window.toggleCompEditability();
        }

        // --- Logik für history.html ---
        function initHistoryPage() {
            const q = query(historyCollectionRef, orderBy("timestamp", "desc"));
            const tableBody = document.getElementById('history-table-body');
            if (!tableBody) return;
            historyUnsubscribe = onSnapshot(q, (querySnapshot) => {
                tableBody.innerHTML = '';
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const row = tableBody.insertRow();
                    row.innerHTML = `
                        <td class="px-6 py-4">${data.boss || 'Allgemein'}</td>
                        <td class="px-6 py-4">${data.assignment}</td>
                        <td class="px-6 py-4 font-medium">${data.player}</td>
                        <td class="px-6 py-4">${data.editor}</td>
                        <td class="px-6 py-4">${data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleString('de-DE') : 'Unbekannt'}</td>
                    `;
                });
            });
        }
		
		function initLootPage() {
			const importSection = document.getElementById('loot-import-section');
			const importBtn = document.getElementById('import-loot-btn');

			if (window.isManager) {
				importSection.style.display = 'block';
				importBtn?.addEventListener('click', handleLootImport);
			}

            // NEU: Event listener für den Zusammenfassungs-Button
            document.getElementById('show-player-summary-btn')?.addEventListener('click', showPlayerSummaryView);

            // Alle Loot-Daten einmalig beim Laden der Seite abrufen
            const allLootQuery = query(lootCollectionRef, orderBy("raidDate", "desc"));
            getDocs(allLootQuery).then(snapshot => {
                allLootDocuments = snapshot.docs.map(doc => ({ id: doc.id, data: doc.data().lootData }));
            });

			const q = query(lootCollectionRef, orderBy("raidDate", "desc"));
			lootDatesUnsubscribe = onSnapshot(q, (snapshot) => {
				const datesList = document.getElementById('loot-dates-list');
				if (!datesList) return;

				if (snapshot.empty) {
					datesList.innerHTML = '<p class="text-gray-500">Keine Loot-Daten gefunden.</p>';
					return;
				}

				datesList.innerHTML = '';
				snapshot.forEach(doc => {
					const date = doc.id;
					const dateButton = document.createElement('button');
					dateButton.className = 'w-full text-left p-2 rounded-md nav-link';
					dateButton.textContent = new Date(date + 'T12:00:00Z').toLocaleDateString('de-DE', { year: 'numeric', month: 'long', day: 'numeric' });
					dateButton.dataset.dateId = date;
					dateButton.onclick = () => {
						document.querySelectorAll('#loot-dates-list button').forEach(btn => btn.classList.remove('active-tab'));
						dateButton.classList.add('active-tab');
						// Diese Funktion schaltet automatisch zurück zur Einzelansicht
						displayLootForDate(date);
					};
					datesList.appendChild(dateButton);
				});
			});
		}

		async function handleLootImport() {
			if (!window.isManager) return;
			const jsonString = document.getElementById('loot-json-input').value;
			if (!jsonString) return window.showModal("Bitte JSON einfügen.");
			
			try {
				const data = JSON.parse(jsonString);
				if (!Array.isArray(data) || data.length === 0) {
					throw new Error("JSON muss ein Array von Loot-Objekten sein und darf nicht leer sein.");
				}

				const firstTimestamp = data[0].timestamp;
				if (!firstTimestamp) throw new Error("Erstes Objekt im JSON hat keinen 'timestamp'.");

				const raidDate = new Date(firstTimestamp * 1000).toISOString().split('T')[0]; // Format: YYYY-MM-DD
				
				const lootDocRef = doc(db, LOOT_COLLECTION, raidDate);
				await setDoc(lootDocRef, { lootData: data, raidDate: raidDate });
				
				const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
				window.logHistory('Loot', `Importiert für ${raidDate}`, `${data.length} Items`, currentManager);
				window.showModal(`Loot für den ${new Date(raidDate + 'T12:00:00Z').toLocaleDateString('de-DE')} wurde erfolgreich importiert!`);
				document.getElementById('loot-json-input').value = '';

			} catch (error) {
				window.showModal("Fehler beim Verarbeiten des JSON: " + error.message);
				console.error(error);
			}
		}

function displayLootForDate(dateId) {
			if (selectedLootDateUnsubscribe) {
				selectedLootDateUnsubscribe();
			}
			const viewTitle = document.getElementById('loot-view-title');
            if(viewTitle) viewTitle.textContent = "Loot-Details";

			const lootDocRef = doc(db, LOOT_COLLECTION, dateId);
			const displayContainer = document.getElementById('loot-details-display');
			displayContainer.innerHTML = '<p class="text-gray-400">Lade Loot-Daten...</p>';

			selectedLootDateUnsubscribe = onSnapshot(lootDocRef, (docSnap) => {
				if (!docSnap.exists()) {
					displayContainer.innerHTML = '<p class="text-red-400">Fehler: Loot-Daten für dieses Datum nicht gefunden.</p>';
					return;
				}

				const lootData = docSnap.data().lootData;
				lootData.sort((a, b) => a.timestamp - b.timestamp);
				
				let html = '';
				lootData.forEach(item => {
					const awardedTo = item.awardedTo.split('-')[0];
					const winnerRoll = item.Rolls.find(r => r.player === awardedTo);
					const winnerClass = winnerRoll ? winnerRoll.class.toUpperCase() : 'UNKNOWN';
					const winnerColor = window.classColors[winnerClass] || '#FFFFFF';

					const rollsHtml = item.Rolls
						.sort((a, b) => b.amount - a.amount)
						.map(roll => {
							const rollType = roll.classification;
							let maxRoll = 100;
							if (rollType === 'OS') maxRoll = 50;
							else if (rollType === 'T-Mog') maxRoll = 25;
							
							const playerColor = window.classColors[roll.class.toUpperCase()] || '#FFFFFF';
							const isWinner = roll.player === awardedTo;
							const fontWeight = isWinner ? 'font-bold text-lg' : 'font-normal';
							const rollColor = isWinner ? 'text-yellow-400' : 'text-gray-300';

							return `<span class="whitespace-nowrap ${fontWeight}"><span style="color:${playerColor}">${roll.player}</span>: <span class="${rollColor}">${roll.amount}</span> <span class="text-xs text-gray-500">(${rollType}/${maxRoll})</span></span>`;
						}).join('&nbsp; ');

					// --- NEU: Wowhead-Link erstellen ---
                    // Item-Namen aus "[Item Name]" extrahieren
                    const itemName = item.itemLink.replace(/[\[\]]/g, ''); 
                    // Wowhead-URL für MoP Classic zusammenbauen
                    const wowheadUrl = `https://www.wowhead.com/mop-classic/item=${item.itemID}`;
                    // Das komplette <a>-Tag für den Link erstellen
                    const itemLinkHtml = `<a href="${wowheadUrl}" target="_blank" rel="noopener noreferrer" class="hover:underline">${itemName}</a>`;
					// --- Ende der neuen Sektion ---

					html += `
						<div class="bg-slate-750 p-4 rounded-lg mb-4">
							<div class="flex justify-between items-start">
								 <h4 class="text-lg font-bold" style="color: var(--color-gold);">${itemLinkHtml}</h4>
								 <span class="text-sm text-gray-400">${new Date(item.timestamp * 1000).toLocaleTimeString('de-DE')}</span>
							</div>
							<p class="mt-1">Vergeben an: <strong style="color: ${winnerColor};">${awardedTo}</strong></p>
							<div class="mt-2 text-sm">
								<p class="font-semibold">Würfe:</p>
								<div class="flex flex-wrap gap-x-4 gap-y-1 mt-1">
									${rollsHtml}
								</div>
							</div>
						</div>
					`;
				});

				displayContainer.innerHTML = html || '<p>Keine Items für dieses Datum gefunden.</p>';
			});
		}

        // --- Logik für Boss-Seiten ---
        function initBossPage(pageId) {
            const assignmentsDocRef = doc(db, DATA_COLLECTION, "boss-" + pageId);
            const sizeToggle = document.getElementById('size-toggle');
            if (sizeToggle) {
                sizeToggle.addEventListener('click', function(event) {
                    if (event.target.matches('.size-toggle-btn')) {
                        const selectedSize = event.target.dataset.size;
                        document.querySelectorAll('.size-toggle-btn').forEach(button => button.classList.remove('active-size-btn'));
                        event.target.classList.add('active-size-btn');
                        document.querySelectorAll('.tactic-content').forEach(content => {
                            content.style.display = content.dataset.size === selectedSize ? (content.tagName === 'SPAN' ? 'inline' : 'block') : 'none';
                        });
                    }
                });
                const defaultSizeButton = document.querySelector(`#size-toggle button[data-size="25"]`);
                if (defaultSizeButton) defaultSizeButton.classList.add('active-size-btn');
                document.querySelectorAll('.tactic-content').forEach(content => {
                    content.style.display = content.dataset.size === '25' ? (content.tagName === 'SPAN' ? 'inline' : 'block') : 'none';
                });
            }

            async function handleAssignmentChange(event) {
                if (!window.isManager) return;
                const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
                const select = event.target;
                const assignmentId = select.dataset.assignmentId;
                const playerName = select.value || "Niemand";
                await setDoc(assignmentsDocRef, { [assignmentId]: { player: playerName, editor: currentManager, timestamp: serverTimestamp() } }, { merge: true });
                const bossName = pageId.charAt(0).toUpperCase() + pageId.slice(1);
                const assignmentName = assignmentId.replace(pageId + '-', '').replace(/([A-Z])/g, ' $1').trim();
                window.logHistory(bossName, `Einteilung: ${assignmentName}`, playerName, currentManager);
            }

            (async () => {
                const rosterSnap = await getDoc(rosterDocRef);
                const rosterData = rosterSnap.exists() ? rosterSnap.data().roster || [] : [];
                
                function populateDropdownOptions(selectElement, players) {
                    selectElement.innerHTML = '<option value="" data-color="#FFFFFF">-- Spieler wählen --</option>';
                    players.forEach(player => {
                        const option = document.createElement('option');
                        const color = window.classColors[player.class.toUpperCase()] || '#FFFFFF';
                        option.value = player.name;
                        option.textContent = `${player.name} (${player.class})`;
                        option.style.color = color;
                        option.dataset.color = color;
                        selectElement.appendChild(option);
                    });
                }
                
                document.querySelectorAll('.assignment-select').forEach(select => {
                    select.addEventListener('change', handleAssignmentChange);
                    const assignmentId = select.dataset.assignmentId.toLowerCase();
                    let playersForDropdown = [];
                    if (assignmentId.includes('tank')) playersForDropdown = rosterData.filter(p => p.roles.includes('TANK'));
                    else if (assignmentId.includes('healer')) playersForDropdown = rosterData.filter(p => p.roles.includes('HEALER'));
                    else if (assignmentId.includes('dps') || assignmentId.includes('dd')) playersForDropdown = rosterData.filter(p => p.roles.includes('DPS'));
                    else playersForDropdown = rosterData;
                    populateDropdownOptions(select, playersForDropdown);
                });

                assignmentUnsubscribe = onSnapshot(assignmentsDocRef, (docSnap) => {
                    const assignments = docSnap.exists() ? docSnap.data() : {};
                    document.querySelectorAll('.assignment-select').forEach(select => {
                        const id = select.dataset.assignmentId;
                        const assignment = assignments[id];
                        const assignedPlayerName = assignment ? assignment.player : "";
                        select.value = assignedPlayerName;
                        const selectedOption = Array.from(select.options).find(o => o.value === assignedPlayerName);
                        select.style.color = selectedOption ? selectedOption.dataset.color : '#FFFFFF';
                    });
                    window.toggleSelectEditability();
                });
                window.toggleSelectEditability();
            })();
        }

        // ============== COMP LOGIK (HELFERFUNKTIONEN) ==============
        function getPlayerInfoFromEntry(playerEntry) {
            let playerClass = playerEntry.class ? playerEntry.class.toUpperCase() : 'UNKNOWN';
            if (playerClass === 'DK') playerClass = 'DEATHKNIGHT';
            let spec = playerEntry.spec;
            const specToClassMap = { 'Guardian': 'DRUID', 'Blood_Tank': 'DEATHKNIGHT', 'Protection': 'WARRIOR', 'Protection1': 'PALADIN', 'Brewmaster': 'MONK' };
            if ((playerClass === 'TANK' || specToClassMap[spec]) && spec) {
                const classFromSpec = specToClassMap[spec];
                if (classFromSpec) playerClass = classFromSpec;
            }
            const tankSpecs = ['Guardian', 'Blood_Tank', 'Protection', 'Protection1', 'Brewmaster'];
            const healerSpecs = ['Restoration', 'Restoration1', 'Discipline', 'Holy', 'Holy1', 'Mistweaver'];
            let role = 'DPS';
            if (tankSpecs.includes(spec)) role = 'TANK';
            else if (healerSpecs.includes(spec)) role = 'HEALER';
            return { name: playerEntry.name, class: playerClass, roles: [role], id: crypto.randomUUID() };
        }

		function displayRoster(roster) {
			const lists = { TANK: document.getElementById('tanks-list'), HEALER: document.getElementById('healers-list'), DPS: document.getElementById('dps-list') };
			if (!lists.TANK) return;
			Object.values(lists).forEach(list => list.innerHTML = '');
		
			function createPlayerElement(player) {
				const playerDiv = document.createElement('div');
				playerDiv.className = 'flex justify-between items-center player-row-container'; 
				playerDiv.dataset.playerId = player.id;
			
				const roleIcons = {
					TANK: '🛡️',
					HEALER: '❤️',
					DPS: '⚔️'
				};
			
				playerDiv.innerHTML = `
					<div class="player-details">
						<input type="text" value="${player.name}" class="editable-name" style="color: ${window.classColors[player.class.toUpperCase()] || '#FFFFFF'};" ${!window.isManager ? 'disabled' : ''}>
						<select class="editable-class-select" ${!window.isManager ? 'disabled' : ''}>
							${wowClasses.map(c => `<option value="${c}" ${player.class === c ? 'selected' : ''}>${c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()}</option>`).join('')}
						</select>
					</div>
					<div class="flex gap-1">
						${['TANK', 'HEALER', 'DPS'].map(role => `
							<button 
								class="role-btn role-${role.toLowerCase()} ${player.roles.includes(role) ? 'active' : ''}" 
								data-role="${role}" 
								${!window.isManager ? 'disabled' : ''}
								style="font-size: 1.25rem; line-height: 1; padding: 0.25rem;"
							>
								${roleIcons[role]} 
							</button>
						`).join('')}
					</div>`;
				return playerDiv;
			}
		
			roster.forEach(player => {
				const playerElement = createPlayerElement(player);
				if (player.roles.includes('TANK')) lists.TANK.appendChild(playerElement.cloneNode(true));
				if (player.roles.includes('HEALER')) lists.HEALER.appendChild(playerElement.cloneNode(true));
				if (player.roles.includes('DPS')) lists.DPS.appendChild(playerElement.cloneNode(true));
			});
		
			roster.forEach(player => {
				document.querySelectorAll(`[data-player-id="${player.id}"]`).forEach(element => {
					const nameInput = element.querySelector('.editable-name');
					nameInput?.addEventListener('blur', (e) => handlePlayerUpdate(e, player.id, 'name'));
					nameInput?.addEventListener('keydown', (event) => {
						if (event.key === 'Enter') {
							event.preventDefault();
							event.target.blur(); 
						}
					});
					const classSelect = element.querySelector('.editable-class-select');
					classSelect?.addEventListener('change', (e) => handlePlayerUpdate(e, player.id, 'class'));
					element.querySelectorAll('.role-btn').forEach(btn => btn.addEventListener('click', () => togglePlayerRole(player.id, btn.dataset.role)));
				});
			});
		
			['TANK', 'HEALER', 'DPS'].forEach(role => {
				if(lists[role] && lists[role].children.length === 0) lists[role].innerHTML = `<p class="text-gray-500">Keine ${role.toLowerCase()}s zugewiesen.</p>`;
			});
			window.toggleCompEditability();
		}

        window.toggleSelectEditability = function() {
            document.querySelectorAll('.assignment-select').forEach(el => { el.disabled = !window.isManager; });
        };
        window.toggleCompEditability = function() {
            if(!document.getElementById('import-btn')) return;
            document.querySelectorAll('#import-btn, #add-player-btn, #clear-roster-btn, .editable-name, .editable-class-select, .role-btn').forEach(el => { el.disabled = !window.isManager; });
        };

        async function handlePlayerUpdate(event, playerId, field) {
            if (!window.isManager) return;
            const docSnap = await getDoc(rosterDocRef);
            if (!docSnap.exists()) return;

            const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
            let roster = docSnap.data().roster || [];
            const playerIndex = roster.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return;

            const oldPlayer = {...roster[playerIndex]};
            const newValue = event.target.value.trim();

            if (field === 'name' && newValue === '') {
                const deletedPlayerName = oldPlayer.name;
                roster.splice(playerIndex, 1);
                await updateDoc(rosterDocRef, { roster: roster });
                window.logHistory('Roster', 'Spieler gelöscht', deletedPlayerName, currentManager);
                window.showModal(`Spieler '${deletedPlayerName}' wurde gelöscht.`);
            } else {
                roster[playerIndex][field] = newValue;
                await updateDoc(rosterDocRef, { roster: roster });
                const changeText = field === 'name' ? `umbenannt in ${newValue}` : `Klasse geändert zu ${newValue}`;
                window.logHistory('Roster', `${oldPlayer.name} ${changeText}`, '', currentManager);
            }
        }

        async function togglePlayerRole(playerId, roleToToggle) {
            if (!window.isManager) return;
            const docSnap = await getDoc(rosterDocRef);
            if (!docSnap.exists()) return;

            const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
            let roster = docSnap.data().roster || [];
            const player = roster.find(p => p.id === playerId);
            if (!player) return;

            let changeText = '';
            const roleIndex = player.roles.indexOf(roleToToggle);
            if (roleIndex > -1) {
                if(player.roles.length > 1) {
                    player.roles.splice(roleIndex, 1);
                    changeText = `Rolle ${roleToToggle} entfernt`;
                }
            } else {
                player.roles.push(roleToToggle);
                changeText = `Rolle ${roleToToggle} hinzugefügt`;
            }

            if(changeText) {
                await updateDoc(rosterDocRef, { roster: roster });
                window.logHistory('Roster', changeText, player.name, currentManager);
            }
        }

        async function handleImportRoster() {
            if (!window.isManager) return;
            const jsonString = document.getElementById('json-input').value;
            if (!jsonString) return window.showModal("Bitte JSON einfügen.");
            try {
                const data = JSON.parse(jsonString);
                if (!data.raidDrop || !Array.isArray(data.raidDrop)) throw new Error("Ungültiges JSON: 'raidDrop' Array fehlt.");
                const newRoster = data.raidDrop.map(getPlayerInfoFromEntry);
                await setDoc(rosterDocRef, { roster: newRoster, rawJson: jsonString });
                const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
                window.logHistory('Roster', `Importiert`, `${newRoster.length} Spieler`, currentManager);
                window.showModal(`Roster mit ${newRoster.length} Spielern importiert!`);
            } catch (error) {
                window.showModal("Fehler beim Verarbeiten des JSON: " + error.message);
            }
        }

        async function handleAddPlayer() {
            if (!window.isManager) return;
            const name = prompt("Name des neuen Spielers:", "NeuerSpieler");
            if (!name) return;
            const newPlayer = { id: crypto.randomUUID(), name: name, class: 'WARRIOR', roles: ['DPS'] };
            const docSnap = await getDoc(rosterDocRef);
            const roster = docSnap.exists() ? docSnap.data().roster || [] : [];
            roster.push(newPlayer);
            await setDoc(rosterDocRef, { roster: roster }, { merge: true });
            const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
            window.logHistory('Roster', `Spieler hinzugefügt`, name, currentManager);
            window.showModal(`Spieler '${name}' wurde hinzugefügt.`);
        }

        async function handleClearRoster() {
            if (!window.isManager) return;
            const confirmed = await window.showModal("Sollen wirklich alle Spieler aus dem Roster entfernt werden?", true);
            if (confirmed) {
                await setDoc(rosterDocRef, { roster: [], rawJson: '' });
                document.getElementById('json-input').value = '';
                const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
                window.logHistory('Roster', 'Geleert', '', currentManager);
                window.showModal("Roster wurde geleert.");
            }
        }

        // ============== RAID BUFF LOGIK ==============
        const raidBuffsClassesMap = {
            // Offensive Buffs
            "5% Stärke, Beweglichkeit, Intelligenz": { classes: { "PALADIN": "Segen der Könige", "DRUID": "Mal der Wildnis", "MONK": "Vermächtnis des Kaisers", "HUNTER": "Umarmung der Schieferkrabbe (Pet)" } },
            "10% Angriffskraft": { classes: { "DEATHKNIGHT": "Horn des Winters", "HUNTER": "Trueshot Aura", "WARRIOR": "Kampfruf" } },
            "10% Angriffsgeschwindigkeit": { classes: { "DEATHKNIGHT": "Unholy Aura", "HUNTER": ["Kicherndes Heulen (Hyänen-Pet)", "Schlangenschnelligkeit (Schlangen-Pet)"], "ROGUE": "List des Schnellklinglers", "SHAMAN": "Entfesselte Wut" } },
            "3000 Meisterschaft": { classes: { "HUNTER": ["Brüllen des Mutes (Katzen-Pet)", "Segen des Geisterbestien (Geisterbestien-Pet)"], "PALADIN": "Segen der Macht", "SHAMAN": "Anmut der Luft" } },
            "5% Kritische Trefferchance": { classes: { "DRUID": "Anführer der Meute", "HUNTER": ["Furchterregendes Brüllen (Wolfs-Pet)", "Ruhiges Wasser (Wasserläufer-Pet)"], "MAGE": "Arkane Brillanz", "MONK": "Vermächtnis des Weißen Tigers", "PRIEST": "Inneres Feuer" } },
            "10% Zaubermacht": { classes: { "HUNTER": "Ruhiges Wasser (Wasserläufer-Pet)", "MAGE": "Arkane Brillanz", "SHAMAN": "Brennender Zorn", "WARLOCK": "Dunkle Absicht" } },
            "5% Zaubertempo": { classes: { "DRUID": "Mondkingestalt", "HUNTER": "Gedankenstärkung (Sporebat-Pet)", "PRIEST": "Schattenform", "SHAMAN": "Elementarer Eid" } },
            // Defensive Buffs
            "10% Ausdauer": { classes: { "HUNTER": "Qiraji-Standhaftigkeit (Silithiden-Pet)", "PRIEST": "Machtwort: Seelenstärke", "WARLOCK": "Dunkle Absicht", "WARRIOR": "Befehlsruf" } },
            "-10% physischer Schaden (Weakened Blows)": { classes: { "DEATHKNIGHT": "Scharlachrotes Fieber (Blut)", "DRUID": "Verwüsten", "HUNTER": ["Demoralisierendes Gebrüll (Bären-Pet)", "Demoralisierender Schrei (Aasvogel-Pet)"], "MONK": "Fass-Sturm (Braumeister)", "PALADIN": "Hammer des Rechtschaffenen (Schutz/Vergeltung)", "SHAMAN": "Erdbeben (Elementar/Verstärkung)", "WARLOCK": "Fluch der Entkräftung", "WARRIOR": "Donnerknall" } },
            // Debuffs (für Gegner)
            "+4% erlittener physischer Schaden (Physical Vulnerability)": { classes: { "DEATHKNIGHT": ["Spröde Knochen (Frost/Unheilig)", "Ebonplaguesprenger (Frost/Unheilig)"], "HUNTER": ["Gore (Eber-Pet)", "Stampede (Nashorn-Pet)", "Säurespucke (Wurm-Pet)", "Verwüsten (Schreiter-Pet)"], "PALADIN": "Urteile des Kühnen (Vergeltung)", "WARRIOR": "Kolossales Zerschmettern (Waffen/Furor)" } },
            "-4% Rüstung (Weakened Armor)": { classes: { "DRUID": "Feenfeuer", "HUNTER": ["Rüstung zerreißen (Raptoren-Pet)", "Staubwolke (Langbein-Pet)"], "ROGUE": "Rüstung zerreißen", "WARRIOR": ["Rüstung zerreißen (Waffen/Furor)", "Verwüsten (Schutz)"] } },
            "+5% erlittener Zauberschaden": { classes: { "HUNTER": ["Feueratem (Drachenfalken-Pet)", "Blitzatem (Windnatter-Pet)"], "ROGUE": "Meistergiftmischer", "WARLOCK": "Fluch der Elemente" } },
            "Heilungsreduktion (Mortal Wounds)": { classes: { "HUNTER": ["Witwengift", "Monströser Biss (Teufelssaurier-Pet)"], "MONK": "Aufsteigende Sonnenkick (Windläufer)", "ROGUE": "Wundgift", "WARRIOR": ["Tödlicher Stoß (Waffen/Furor)", "Wilder Stoß (Waffen/Furor)"] } },
            "Zaubergeschwindigkeitsreduktion": { classes: { "DEATHKNIGHT": "Nekrotischer Stoß", "HUNTER": ["Lava-Atem (Kernhund-Pet)", "Sporenwolke (Sporebat-Pet)"], "MAGE": "Verlangsamen (Arkan)", "ROGUE": "Gedankenbenebelndes Gift", "WARLOCK": "Fluch der Entkräftung" } },
            // Raid Cooldowns
            "Blutdurst/Heldentum": { classes: { "SHAMAN": "Blutdurst", "MAGE": "Zeitkrümmung", "HUNTER": "Uralte Hysterie (Exotisches Kernelementar-Pet)" } },
            "Schädelfahne": { classes: { "WARRIOR": "Schädelfahne" } },
            "Sturmhagel-Totem": { classes: { "SHAMAN": "Sturmhagel-Totem" } },
            "Antimagische Zone": { classes: { "DEATHKNIGHT": "Antimagische Zone" } },
            "Demoralisierende Standarte": { classes: { "WARRIOR": "Demoralisierende Standarte" } },
            "Hingabe-Aura": { classes: { "PALADIN": "Hingabe-Aura" } },
            "Machtwort: Barriere": { classes: { "PRIEST": "Machtwort: Barriere" } },
            "Sammelruf": { classes: { "WARRIOR": "Sammelruf" } },
            "Rauchbombe": { classes: { "ROGUE": "Rauchbombe" } },
            "Geisterverbindungstotem": { classes: { "SHAMAN": "Geisterverbindungstotem" } }
        };

        window.updateRaidBuffsDisplay = function(roster) {
            if (!roster) return;

            const rosterClassCounts = {};
            roster.forEach(player => {
                const playerClass = player.class.toUpperCase();
                rosterClassCounts[playerClass] = (rosterClassCounts[playerClass] || 0) + 1;
            });

            document.querySelectorAll('.buff-item').forEach(buffItem => {
                const buffName = buffItem.dataset.buffName;
                const buffData = raidBuffsClassesMap[buffName];
                const buffInfoSpan = buffItem.querySelector('.buff-info');
                if (!buffInfoSpan) return;

                let availableCount = 0;
                let tooltipLines = [];

                if (buffData && buffData.classes) {
                    for (const className in buffData.classes) {
                        const countInRoster = rosterClassCounts[className] || 0;
                        if (countInRoster > 0) {
                            availableCount += countInRoster;
                            const classAbility = buffData.classes[className];
                            const abilityNames = Array.isArray(classAbility) ? classAbility : [classAbility];
                            const color = window.classColors[className] || '#FFFFFF';
                            abilityNames.forEach(abilityName => {
                                 tooltipLines.push(`<span style="color: ${color};">${className.charAt(0).toUpperCase() + className.slice(1).toLowerCase()}</span>: ${abilityName}`);
                            });
                        }
                    }
                }

                if (availableCount > 0) {
                    buffItem.classList.remove('opacity-50');
                    buffItem.style.fontWeight = 'bold';
                    buffItem.style.color = 'inherit';
                    buffInfoSpan.textContent = ` (${availableCount})`;
                } else {
                    buffItem.classList.add('opacity-50');
                    buffItem.style.fontWeight = 'normal';
                    buffItem.style.color = '#a0aec0';
                    buffInfoSpan.textContent = ` (0)`;
                }

                buffItem.style.position = 'relative';
                buffItem.style.cursor = 'help';
                
                let tooltipDiv = buffItem.querySelector('.buff-tooltip');
                if (!tooltipDiv) {
                    tooltipDiv = document.createElement('div');
                    tooltipDiv.className = 'buff-tooltip hidden';
                    buffItem.appendChild(tooltipDiv);
                }
                tooltipDiv.innerHTML = tooltipLines.join('<br>');

                buffItem.onmouseover = () => {
                    if (tooltipLines.length > 0) {
                        tooltipDiv.classList.remove('hidden');
                    }
                };
                buffItem.onmouseout = () => {
                    tooltipDiv.classList.add('hidden');
                };
            });
        };
        function showPlayerSummaryView() {
            const displayContainer = document.getElementById('loot-details-display');
            const viewTitle = document.getElementById('loot-view-title');
            if (!displayContainer || !viewTitle) return;

            viewTitle.textContent = "Spieler-Zusammenfassung";
            playerSummaryState = {}; // Zustand zurücksetzen
            summarySortState = { column: 'total', direction: 'desc' };


            if (allLootDocuments.length === 0) {
                displayContainer.innerHTML = '<p class="text-gray-500">Keine Loot-Daten zum Auswerten vorhanden.</p>';
                return;
            }

            const datesHtml = allLootDocuments.map(doc => `
                <label class="flex items-center space-x-2 p-2 rounded-md hover:bg-slate-700 cursor-pointer transition-colors duration-150">
                    <input type="checkbox" data-date-id="${doc.id}" class="summary-date-checkbox form-checkbox h-5 w-5 rounded bg-slate-900 border-slate-600 text-jade-400 focus:ring-jade-400">
                    <span>${new Date(doc.id + 'T12:00:00Z').toLocaleDateString('de-DE', { month: 'long', day: 'numeric' })}</span>
                </label>
            `).join('');

            displayContainer.innerHTML = `
                <div class="flex justify-between items-center mb-4">
                    <p class="text-gray-400">Wähle die Daten aus, die einbezogen werden sollen.</p>
                    <div class="flex gap-2">
                        <button id="summary-select-all-btn" class="text-sm py-1 px-3 rounded-md bg-blue-600 hover:bg-blue-700">Alle</button>
                        <button id="summary-deselect-all-btn" class="text-sm py-1 px-3 rounded-md bg-slate-600 hover:bg-slate-500">Keine</button>
                    </div>
                </div>
                <div id="summary-dates-grid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2 mb-6 p-4 bg-slate-900/50 rounded-lg border border-slate-700">
                    ${datesHtml}
                </div>
                <div id="player-summary-results">
                    <p class="text-gray-500 text-center py-4">Bitte mindestens ein Datum auswählen.</p>
                </div>
            `;
            
            // KORREKTUR: Der Listener wird präziser gesetzt, um das Bubbling-Problem zu beheben.
            document.getElementById('summary-dates-grid').addEventListener('change', (event) => {
                if (event.target.classList.contains('summary-date-checkbox')) {
                    handleSummaryDateSelection();
                }
            });
            document.getElementById('summary-select-all-btn')?.addEventListener('click', () => toggleAllSummaryCheckboxes(true));
            document.getElementById('summary-deselect-all-btn')?.addEventListener('click', () => toggleAllSummaryCheckboxes(false));
        }

        function toggleAllSummaryCheckboxes(select) {
            document.querySelectorAll('.summary-date-checkbox').forEach(cb => cb.checked = select);
            handleSummaryDateSelection();
        }

function handleSummaryDateSelection() {
            const selectedDates = Array.from(document.querySelectorAll('.summary-date-checkbox:checked'))
                                       .map(cb => cb.dataset.dateId);

            const oldState = { ...playerSummaryState }; // Den alten Zustand für die offenen Menüs sichern
            playerSummaryState = {}; 

            if (selectedDates.length > 0) {
                const filteredLootItems = allLootDocuments
                    .filter(doc => selectedDates.includes(doc.id))
                    .flatMap(doc => doc.data);

                filteredLootItems.forEach(item => {
                    if (!item.received || !item.checksum) return; // Sicherstellen, dass ein Checksum vorhanden ist
                    
                    const winner = item.awardedTo.split('-')[0];
                    let rollTypeSource = '';

                    if (item.winningRollType) {
                        rollTypeSource = item.winningRollType;
                    } else {
                        const winningRoll = item.Rolls.find(roll => roll.player === winner);
                        if (winningRoll && winningRoll.classification) {
                            rollTypeSource = winningRoll.classification;
                        } else { return; }
                    }

                    const rollType = rollTypeSource.toUpperCase();
                    let category;
                    if (rollType === 'MS') category = 'ms';
                    else if (rollType === 'OS') category = 'os';
                    else if (['T-MOG', 'TRANSMOG', 'STYLE'].includes(rollType)) category = 'transmog';
                    else return;

                    if (!playerSummaryState[winner]) {
                        playerSummaryState[winner] = { items: [], isDetailsOpen: oldState[winner]?.isDetailsOpen || false };
                    }
                    
                    playerSummaryState[winner].items.push({
                        name: item.itemLink.replace(/[\[\]]/g, ''),
                        id: item.itemID,
                        // KORREKTUR: Wir verwenden item.checksum statt item.itemGUID
                        uniqueId: item.checksum, 
                        category: category,
                        included: true
                    });
                });
            }
            
            drawPlayerSummaryTable();
        }

function renderPlayerSummary(selectedDates) {
            const resultsContainer = document.getElementById('player-summary-results');
            if (selectedDates.length === 0) {
                resultsContainer.innerHTML = '<p class="text-gray-500 text-center py-4">Bitte mindestens ein Datum auswählen.</p>';
                return;
            }

            const playerStats = {};
            const filteredLootItems = allLootDocuments
                .filter(doc => selectedDates.includes(doc.id))
                .flatMap(doc => doc.data);

            filteredLootItems.forEach(item => {
                if (!item.received) return;
                
                const winner = item.awardedTo.split('-')[0];
                let rollTypeSource = '';

                // --- NEUE, INTELLIGENTERE LOGIK ---
                // 1. Versuche, den direkten Typ zu verwenden
                if (item.winningRollType) {
                    rollTypeSource = item.winningRollType;
                } 
                // 2. Wenn das Feld fehlt, finde den Wurf des Gewinners und nutze dessen Klassifizierung
                else {
                    const winningRoll = item.Rolls.find(roll => roll.player === winner);
                    if (winningRoll && winningRoll.classification) {
                        rollTypeSource = winningRoll.classification;
                    } else {
                        // Wenn wir den Typ nicht bestimmen können, überspringe das Item.
                        return;
                    }
                }
                // --- ENDE DER NEUEN LOGIK ---

                const rollType = rollTypeSource.toUpperCase();
                let category;
                if (rollType === 'MS') {
                    category = 'ms';
                } else if (rollType === 'OS') {
                    category = 'os';
                } else if (['T-MOG', 'TRANSMOG', 'STYLE'].includes(rollType)) {
                    category = 'transmog';
                } else {
                    return;
                }

                if (!playerStats[winner]) {
                    playerStats[winner] = { ms: 0, os: 0, transmog: 0, total: 0 };
                }

                playerStats[winner][category]++;
                playerStats[winner].total++;
            });

            const statsArray = Object.entries(playerStats).map(([name, stats]) => ({ name, ...stats }));
            statsArray.sort((a, b) => b.total - a.total || a.name.localeCompare(b.name));

            const tableRows = statsArray.map(player => `
                <tr class="border-b border-slate-700 hover:bg-slate-750/50">
                    <td class="px-4 py-3 font-medium">${player.name}</td>
                    <td class="px-4 py-3 text-center">${player.ms}</td>
                    <td class="px-4 py-3 text-center">${player.os}</td>
                    <td class="px-4 py-3 text-center">${player.transmog}</td>
                    <td class="px-4 py-3 text-center font-bold text-gold">${player.total}</td>
                </tr>
            `).join('');

            resultsContainer.innerHTML = `
                <div class="overflow-x-auto rounded-lg border border-slate-700">
                    <table class="min-w-full text-sm text-left text-gray-300">
                        <thead class="text-xs text-gray-400 uppercase bg-slate-700">
                            <tr>
                                <th scope="col" class="px-4 py-3">Spieler</th>
                                <th scope="col" class="px-4 py-3 text-center">MS</th>
                                <th scope="col" class="px-4 py-3 text-center">OS</th>
                                <th scope="col" class="px-4 py-3 text-center">Transmog</th>
                                <th scope="col" class="px-4 py-3 text-center">Total</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-slate-700">
                            ${tableRows.length > 0 ? tableRows : '<tr><td colspan="5" class="text-center p-4 text-gray-500">Keine zählbaren Loot-Daten für die Auswahl gefunden.</td></tr>'}
                        </tbody>
                    </table>
                </div>
            `;
        }
function drawPlayerSummaryTable() {
            const resultsContainer = document.getElementById('player-summary-results');
            const players = Object.keys(playerSummaryState);

            if (players.length === 0) {
                resultsContainer.innerHTML = '<p class="text-gray-500 text-center py-4">Bitte mindestens ein Datum auswählen.</p>';
                return;
            }

            const statsArray = players.map(name => {
                const includedItems = playerSummaryState[name].items.filter(item => item.included);
                return {
                    name: name,
                    ms: includedItems.filter(item => item.category === 'ms').length,
                    os: includedItems.filter(item => item.category === 'os').length,
                    transmog: includedItems.filter(item => item.category === 'transmog').length,
                    total: includedItems.length
                };
            });
            
            // --- NEU: Sortierlogik ---
            const { column, direction } = summarySortState;
            statsArray.sort((a, b) => {
                if (a[column] !== b[column]) {
                    return direction === 'desc' ? b[column] - a[column] : a[column] - b[column];
                }
                // Sekundäre Sortierung nach Total, dann nach Name
                if (b.total !== a.total) return b.total - a.total;
                return a.name.localeCompare(b.name);
            });
            // --- ENDE Sortierlogik ---

            const tableRows = statsArray.map(player => {
                const itemsHtml = playerSummaryState[player.name].items.map(item => {
                    const wowheadUrl = `https://www.wowhead.com/mop-classic/item=${item.id}`;
                    return `<div class="flex items-center gap-2 px-2 py-1"><input type="checkbox" class="item-inclusion-checkbox" data-player-name="${player.name}" data-item-id="${item.uniqueId}" ${item.included ? 'checked' : ''}><a href="${wowheadUrl}" target="_blank" rel="noopener noreferrer" class="hover:underline text-sm">[${item.name}]</a><span class="text-xs uppercase bg-slate-600 px-1.5 py-0.5 rounded-full">${item.category}</span></div>`;
                }).join('');
                const isHidden = playerSummaryState[player.name].isDetailsOpen ? '' : 'hidden';
                const rotation = playerSummaryState[player.name].isDetailsOpen ? 'rotate-90' : '';
                return `<tr class="border-b border-slate-700 hover:bg-slate-750/50"><td class="px-4 py-3 font-medium"><button class="toggle-details-btn flex items-center gap-2" data-player-name="${player.name}">${player.name} <span class="text-xs text-gray-400 transition-transform ${rotation}">▶</span></button></td><td class="px-4 py-3 text-center">${player.ms}</td><td class="px-4 py-3 text-center">${player.os}</td><td class="px-4 py-3 text-center">${player.transmog}</td><td class="px-4 py-3 text-center font-bold text-gold">${player.total}</td></tr><tr class="item-details-row ${isHidden} bg-slate-800"><td colspan="5" class="p-2"><div class="flex flex-col gap-1">${itemsHtml}</div></td></tr>`;
            }).join('');

            // --- NEU: Dynamische Kopfzeile mit Sortier-Buttons ---
            const sortableColumns = { 'MS': 'ms', 'OS': 'os', 'Transmog': 'transmog', 'Total': 'total' };
            const headerHtml = Object.entries(sortableColumns).map(([title, key]) => {
                const isActive = summarySortState.column === key;
                const indicator = isActive ? (summarySortState.direction === 'desc' ? '▼' : '▲') : '';
                return `<th scope="col" class="px-4 py-3 text-center"><button class="sort-btn font-bold uppercase ${isActive ? 'text-gold' : 'text-gray-400'}" data-sort-column="${key}">${title} <span class="indicator w-4 inline-block">${indicator}</span></button></th>`;
            }).join('');

            resultsContainer.innerHTML = `<div class="overflow-x-auto rounded-lg border border-slate-700"><table class="min-w-full text-sm text-left text-gray-300"><thead class="text-xs uppercase bg-slate-700"><tr><th scope="col" class="px-4 py-3">Spieler</th>${headerHtml}</tr></thead><tbody class="divide-y divide-slate-700">${tableRows}</tbody></table></div>`;
            
            // Event Listener hinzufügen
            resultsContainer.querySelectorAll('.toggle-details-btn').forEach(btn => btn.addEventListener('click', handleToggleDetails));
            resultsContainer.querySelectorAll('.item-inclusion-checkbox').forEach(cb => cb.addEventListener('change', handleItemInclusionChange));
            resultsContainer.querySelectorAll('.sort-btn').forEach(btn => btn.addEventListener('click', handleSummarySort));
        }
		function handleSummarySort(event) {
            const newColumn = event.currentTarget.dataset.sortColumn;
            if (summarySortState.column === newColumn) {
                // Wenn die selbe Spalte geklickt wird, Richtung umkehren
                summarySortState.direction = summarySortState.direction === 'desc' ? 'asc' : 'desc';
            } else {
                // Bei Klick auf eine neue Spalte, diese als aktiv setzen und Standardrichtung (desc) wählen
                summarySortState.column = newColumn;
                summarySortState.direction = 'desc';
            }
            // Tabelle mit neuer Sortierung neu zeichnen
            drawPlayerSummaryTable();
        }

        // ZWEI WEITERE NEUE FUNKTIONEN
function handleToggleDetails(event) {
            const button = event.currentTarget;
            // KORREKTUR: Spielername wird aus data-Attribut gelesen (sicherer)
            const playerName = button.dataset.playerName;
            
            if (playerSummaryState[playerName]) {
                // Den Zustand im State-Objekt umschalten
                playerSummaryState[playerName].isDetailsOpen = !playerSummaryState[playerName].isDetailsOpen;
            }
            
            // Tabelle neu zeichnen, um die Änderung (offen/geschlossen) anzuzeigen
            drawPlayerSummaryTable();
        }

function handleItemInclusionChange(event) {
            const checkbox = event.target;
            const playerName = checkbox.dataset.playerName;
            // KORREKTUR: Wir lesen das data-item-id Attribut
            const itemId = checkbox.dataset.itemId;

            // KORREKTUR: Wir finden das Item anhand der neuen uniqueId Eigenschaft
            const item = playerSummaryState[playerName]?.items.find(i => i.uniqueId === itemId);
            if (item) {
                item.included = checkbox.checked;
            }
            drawPlayerSummaryTable();
        }
    </script>
</body>
</html>