<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raid Guides - PÄNIK</title>
	<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* FINALES "MISTS OF PANDARIA" THEMA MIT ALLEN FEHLERBEHEBUNGEN */
        :root {
            --color-gold: #fcd34d;
            --color-jade: #5eead4;
            --color-parchment: #f5f2e8;
            --color-dark-green-bg: rgba(25, 42, 35, 0.92);
            --color-medium-green-bg: rgba(36, 61, 51, 0.88);
            --color-dark-text: #102a23;
            --color-gold-border: rgba(204, 163, 76, 0.4);
            --color-gold-border-light: rgba(204, 163, 76, 0.2);
        }
        body { 
            font-family: 'Inter', sans-serif;
            color: var(--color-parchment);
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Cinzel', serif;
            letter-spacing: 0.05em;
        }
        .main-container {
            background-color: var(--color-dark-green-bg);
            border: 1px solid var(--color-gold-border);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
        /* Diese Klassen überschreiben die alten, falls sie im dynamischen HTML noch vorkommen */
        .bg-slate-850, .bg-slate-750 {
            background-color: var(--color-medium-green-bg) !important;
            border: 1px solid var(--color-gold-border-light) !important;
        }
        .text-blue-450 { color: var(--color-gold) !important; }
        .border-slate-650 { border-color: var(--color-gold-border) !important; }
        .text-gold { color: var(--color-gold); }

        .nav-link { 
            background-color: rgba(74, 115, 95, 0.6); 
            border: 1px solid var(--color-gold-border-light);
            transition: all 0.2s ease-in-out;
            color: var(--color-parchment);
            font-family: 'Cinzel', serif;
            font-weight: bold;
        }
        .nav-link:hover {
            background-color: rgba(87, 135, 111, 0.8);
            border-color: var(--color-gold-border);
        }
        .nav-link.active-tab { 
            background-color: var(--color-jade);
            color: var(--color-dark-text) !important;
            border-color: #99f6e4;
            box-shadow: 0 0 15px rgba(94, 234, 212, 0.4);
            transform: translateY(-2px);
        }
        
        button, .btn { font-family: 'Cinzel', serif; font-weight: bold; transition: all 0.2s ease-in-out; }
        button:disabled { opacity: 0.5 !important; cursor: not-allowed !important; }

        .bg-blue-600 { background-color: #ca8a04 !important; color: var(--color-dark-text) !important; }
        .bg-blue-600:hover { background-color: #eab308 !important; }
        .bg-green-600, .bg-green-700 { background-color: #15803d !important; color: var(--color-parchment) !important; }
        .bg-green-600:hover, .bg-green-700:hover { background-color: #16a34a !important; }
        .bg-red-700, .bg-red-800, .cancel-btn { background-color: #b91c1c !important; color: var(--color-parchment) !important; }
        .bg-red-700:hover, .bg-red-800:hover, .cancel-btn:hover { background-color: #dc2626 !important; }

        #raid-selector, .assignment-select {
            background-color: rgba(10, 20, 15, 0.7) !important;
            border: 1px solid var(--color-gold-border) !important;
            color: var(--color-parchment);
            border-radius: 0.25rem;
        }
        
        .editable-name {
            background-color: transparent !important;
            border: 1px solid transparent !important;
            border-radius: 4px;
            padding: 2px 4px;
        }
        .editable-name:hover:not(:disabled), .editable-name:focus {
             background-color: rgba(10, 20, 15, 0.7) !important;
             border: 1px solid var(--color-gold-border) !important;
        }
        .editable-class-select {
             background-color: rgba(10, 20, 15, 0.7) !important;
             border: 1px solid var(--color-gold-border) !important;
             color: var(--color-parchment) !important;
        }
        #json-input { background-color: rgba(10, 20, 15, 0.7) !important; border: 1px solid var(--color-gold-border) !important; color: #a0aec0 !important; }

        #background-video { position: fixed; right: 0; bottom: 0; min-width: 100%; min-height: 100%; z-index: -100; object-fit: cover; filter: brightness(0.4); }
        .content-wrapper { position: relative; z-index: 2; }
        
        /* KORREKTUR: Login Modal Overlay Styling */
        .login-modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .login-modal-content {
            background-color: var(--color-dark-green-bg);
            border: 1px solid var(--color-gold-border);
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            text-align: center;
            width: 90%;
            max-width: 400px;
        }
        .login-modal-content h3 { font-size: 1.5rem; margin-bottom: 1.5rem; color: var(--color-gold); }
        .login-modal-content input { background-color: rgba(10, 20, 15, 0.7) !important; border: 1px solid var(--color-gold-border) !important; color: var(--color-parchment) !important; border-radius: 0.25rem; padding: 0.5rem; width: 100%; margin-bottom: 1rem; }
        .login-modal-buttons { display: flex; justify-content: center; gap: 1rem; margin-top: 1.5rem; }

		/* KORREKTUR: Roster-Button Farben und Hervorhebung */
		.role-btn { 
			border: 2px solid transparent; /* Transparenter Rand, um Layout-Sprünge zu vermeiden */
			background-color: rgba(0,0,0,0.2); 
			color: rgba(204, 163, 76, 0.7); 
			opacity: 0.7; 
			border-radius: 6px;
		}
		.role-btn:not(:disabled):hover { 
			opacity: 1;
			border-color: #ca8a04;
		}
		.role-btn.active { 
			opacity: 1; 
			transform: scale(1.1); /* Aktives Icon leicht vergrößern */
			background-color: transparent !important; /* Sicherstellen, dass der Hintergrund weg ist */
		}
		.role-btn.role-tank.active { 
			border-color: #60a5fa !important;
			box-shadow: 0 0 8px #60a5fa;
		}
		.role-btn.role-healer.active { 
			border-color: #34d399 !important; 
			box-shadow: 0 0 8px #34d399;
		}
		.role-btn.role-dps.active { 
			border-color: #f87171 !important; 
			box-shadow: 0 0 8px #f87171;
		}

        /* Originale Klassen zur Sicherheit beibehalten und überschreiben */
        .text-gray-200, .text-white { color: var(--color-parchment); }
        .text-gray-400 { color: #a0aec0; }
        .buff-tooltip { position: absolute; z-index: 100; background-color: #1a202c; border: 1px solid #4a5568; padding: 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; color: #e2e8f0; white-space: nowrap; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
    /* KORREKTUR: Fehlende Stile für das allgemeine Modal-Fenster */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background-color: var(--color-dark-green-bg);
            border: 1px solid var(--color-gold-border);
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            text-align: center;
            width: 90%;
            max-width: 450px;
        }
        .modal-content h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--color-gold);
        }
        .modal-content p {
            margin-bottom: 1.5rem;
            font-family: 'Inter', sans-serif;
            color: var(--color-parchment);
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        .modal-buttons button {
            padding: 0.5rem 1.5rem;
            border-radius: 0.25rem;
            color: var(--color-dark-text) !important;
            background-color: #ca8a04 !important;
        }
        .modal-buttons button:hover {
            background-color: #eab308 !important;
        }
        .modal-buttons .cancel-btn {
            background-color: #b91c1c !important;
            color: var(--color-parchment) !important;
        }
        .modal-buttons .cancel-btn:hover {
            background-color: #dc2626 !important;
        }
		.player-details {
			display: flex;
			flex-direction: column; /* ÄNDERUNG: Stellt die Elemente untereinander dar */
			align-items: flex-start; /* ÄNDERUNG: Richtet sie linksbündig aus */
			gap: 0.25rem; /* Fügt einen kleinen Abstand zwischen Name und Klasse hinzu */
			min-width: 0; 
		}
		.editable-name, .editable-class-select {
			width: 160px; /* Gibt beiden Elementen eine feste Breite */
		}
		
		/* Responsive Anpassung für den Roster auf kleinen Bildschirmen */
		@media (max-width: 767px) {
			.player-row-container {
				flex-direction: column; /* Stellt die Elemente untereinander dar */
				align-items: flex-start; /* Richtet alles linksbündig aus */
				gap: 0.5rem; /* Fügt einen kleinen Abstand hinzu */
				padding-bottom: 0.75rem;
				border-bottom: 1px solid var(--color-gold-border-light);
			}
			.player-row-container:last-child {
				border-bottom: none; /* Entfernt den Rand beim letzten Element */
			}
			.player-row-container .player-details {
				width: 100%; /* Sektion mit Name/Klasse soll volle Breite nutzen */
			}
		}
	</style>
</head>
<body>
<video autoplay muted loop playsinline id="background-video">
    <source src="static/background.webm" type="video/webm">
</video>
<div class="content-wrapper">
    <div class="max-w-7xl mx-auto main-container p-6 rounded-lg shadow-2xl relative">
        <div id="auth-section"></div>
        <header class="text-center pb-4 mb-6 border-b border-slate-650">
            <h1 class="text-5xl font-bold text-gold">P Ä N I K Raidsheet</h1>
             <div class="flex justify-center items-center gap-2 mt-2">
                <p class="text-lg text-gray-400">Strategien und Einteilungen</p>
                <div id="presence-indicator" class="flex items-center gap-2 text-sm text-gray-400"></div>
            </div>
        </header>

        <h2 class="text-2xl font-semibold text-center text-blue-450 mb-4">Navigation</h2>
        <div class="flex justify-center mb-4">
            <label for="raid-selector" class="sr-only">Raid auswählen</label>
            <select id="raid-selector" class="bg-slate-850 text-gray-200 p-2 rounded-md border border-slate-650 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="mogushan" selected>Mogu'shangewölbe</option>
                <option value="heartoffear">Das Herz der Angst</option>
                <option value="terraceofendlessspring">Terrasse des Endlosen Frühlings</option>
                <option value="throneofthunder">Der Thron des Donners</option>
                <option value="siegeoforgrimmar">Schlacht um Orgrimmar</option>
            </select>
        </div>
        <nav id="boss-nav" class="flex flex-wrap justify-center gap-2 mb-8">
            </nav>

        <main id="content-container">
            </main>
    </div>

    <div id="login-modal-overlay" class="login-modal-overlay hidden">
        <div class="login-modal-content">
            <h3>Gildenrat-Login</h3>
            <input type="text" id="login-username" placeholder="Benutzername" required>
            <input type="password" id="login-password" placeholder="Passwort" required>
            <div class="login-modal-buttons">
                <button id="login-modal-cancel-btn" class="cancel-btn">Abbrechen</button>
                <button id="login-modal-submit-btn">Login</button>
            </div>
        </div>
    </div>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc, getDoc, serverTimestamp, query, orderBy, addDoc, updateDoc, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // ============== INITIALISIERUNG & GLOBALE VARIABLEN ==============
        const firebaseConfig = {
            apiKey: "AIzaSyBmqCCIOKq0OQOTEgJJ7Lj8CYlLihVBVSU",
            authDomain: "panik-raid.firebaseapp.com",
            projectId: "panik-raid",
            storageBucket: "panik-raid.appspot.com",
            messagingSenderId: "120578974053",
            appId: "1:120578974053:web:927a81dccbb4b33f86c18c"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        window.isManager = false;
        let currentRosterUnsubscribe = null;
        let historyUnsubscribe = null;
        let assignmentUnsubscribe = null;
        let heartbeatIntervalId = null;

        const DATA_COLLECTION = "raid-tool-data";
        const HISTORY_COLLECTION = "raid-tool-history";
        const USER_PROFILES_COLLECTION = "user_profiles";

        const raidData = {
            mogushan: {
                name: "Mogu'shangewölbe",
                bosses: [
                    { id: 'steinwache', name: 'Die Steinwache' },
                    { id: 'feng', name: 'Feng der Verfluchte' },
                    { id: 'garajal', name: 'Gara\'jal der Geisterbinder' },
                    { id: 'geisterkoenige', name: 'Die Geisterkönige' },
                    { id: 'elegon', name: 'Elegon' },
                    { id: 'wille', name: 'Wille des Kaisers' }
                ]
            },
            heartoffear: {
                name: "Das Herz der Angst",
                bosses: [
                    { id: 'zorlok', name: 'Kaiserlicher Wesir Zor\'lok' },
                    { id: 'tayak', name: 'Klingenfürst Ta\'yak' },
                    { id: 'garalon', name: 'Garalon' },
                    { id: 'meljarak', name: 'Windfürst Mel\'jarak' },
                    { id: 'unsof', name: 'Bernformer Un\'sok' },
                    { id: 'shekzeer', name: 'Großkaiserin Shek\'zeer' }
                ]
            },
            terraceofendlessspring: {
                name: "Terrasse des Endlosen Frühlings",
                bosses: [
                    { id: 'protectors', name: 'Beschützer des Endlosen' },
                    { id: 'tsulong', name: 'Tsulong' },
                    { id: 'lei-shi', name: 'Lei Shi' },
                    { id: 'sha-of-fear', name: 'Sha der Angst' }
                ]
            },
            throneofthunder: {
                name: "Der Thron des Donners",
                bosses: [
                    { id: 'jinrokh', name: 'Jin\'rokh der Zerstörer' },
                    { id: 'horridon', name: 'Horridon' },
                    { id: 'council', name: 'Rat der Ältesten' },
                    { id: 'tortos', name: 'Tortos' },
                    { id: 'megaira', name: 'Megaira' },
                    { id: 'ji-kun', name: 'Ji-Kun' },
                    { id: 'durumu', name: 'Durumu der Vergessene' },
                    { id: 'primordius', name: 'Primordius' },
                    { id: 'dark-animus', name: 'Dunkler Animus' },
                    { id: 'iron-qon', name: 'Eiserner Qon' },
                    { id: 'twin-consorts', name: 'Zwillingskonkubinen' },
                    { id: 'lei-shen', name: 'Lei Shen' },
                    { id: 'ra-den', name: 'Ra-den' }
                ]
            },
            siegeoforgrimmar: {
                name: "Schlacht um Orgrimmar",
                bosses: [
                    { id: 'immerseus', name: 'Immerseus' },
                    { id: 'fallen-protectors', name: 'Die gefallenen Beschützer' },
                    { id: 'norushen', name: 'Norushen' },
                    { id: 'sha-of-pride', name: 'Sha des Stolzes' },
                    { id: 'galakras', name: 'Galakras' },
                    { id: 'iron-juggernaut', name: 'Eiserner Koloss' },
                    { id: 'korkron-dark-shamans', name: 'Dunkelschamanen der Kor\'kron' },
                    { id: 'general-nazgrim', name: 'General Nazgrim' },
                    { id: 'malkorok', name: 'Malkorok' },
                    { id: 'spoils-of-pandaria', name: 'Die Schätze Pandarias' },
                    { id: 'thok', name: 'Thok der Blutrünstige' },
                    { id: 'siegecrafter', name: 'Belagerungsingenieur Rußschmied' },
                    { id: 'paragons', name: 'Die Getreuen der Klaxxi' },
                    { id: 'garrosh', name: 'Garrosh Höllschrei' }
                ]
            }
        };

        window.classColors = { 'DEATHKNIGHT': '#C41F3B', 'DK': '#C41F3B', 'DRUID': '#FF7D0A', 'HUNTER': '#AAD372', 'MAGE': '#3FC7EB', 'MONK': '#00FF96', 'PALADIN': '#F48CBA', 'PRIEST': '#FFFFFF', 'ROGUE': '#FFF569', 'SHAMAN': '#0070DD', 'WARLOCK': '#8788EE', 'WARRIOR': '#C69B6D', 'TANK': '#A3A3A3' };
        const wowClasses = ['WARRIOR', 'PALADIN', 'HUNTER', 'ROGUE', 'PRIEST', 'DEATHKNIGHT', 'SHAMAN', 'MAGE', 'WARLOCK', 'MONK', 'DRUID'];
        const rosterDocRef = doc(db, DATA_COLLECTION, "currentRoster");
        const historyCollectionRef = collection(db, HISTORY_COLLECTION);
        const userProfilesCollectionRef = collection(db, USER_PROFILES_COLLECTION);

        // ============== MODAL-FUNKTION (global verfügbar) ==============
        window.showModal = function(message, isConfirm = false) {
            return new Promise((resolve) => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.innerHTML = `
                    <div class="modal-content">
                        <h3>Nachricht</h3>
                        <p>${message}</p>
                        <div class="modal-buttons">
                            ${isConfirm ? `<button id="modal-cancel-btn" class="cancel-btn">Abbrechen</button>` : ''}
                            <button id="modal-ok-btn">OK</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('modal-ok-btn').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });

                if (isConfirm) {
                    document.getElementById('modal-cancel-btn').addEventListener('click', () => {
                        document.body.removeChild(modalOverlay);
                        resolve(false);
                    });
                }
            });
        };
        
        // ============== LOGIN MODAL FUNKTION ==============
        function showLoginModal() {
             return new Promise((resolve) => {
                const loginModalOverlay = document.getElementById('login-modal-overlay');
                const loginUsernameInput = document.getElementById('login-username');
                const loginPasswordInput = document.getElementById('login-password');
                const loginSubmitBtn = document.getElementById('login-modal-submit-btn');
                const loginCancelBtn = document.getElementById('login-modal-cancel-btn');

                loginUsernameInput.value = '';
                loginPasswordInput.value = '';
                loginModalOverlay.classList.remove('hidden');

                const handleSubmit = async () => {
                    const username = loginUsernameInput.value;
                    const password = loginPasswordInput.value;

                    if (!username || !password) {
                        window.showModal("Bitte Benutzername und Passwort eingeben.");
                        return;
                    }

                    try {
                        const q = query(userProfilesCollectionRef, where("username", "==", username));
                        const querySnapshot = await getDocs(q);

                        if (querySnapshot.empty) {
                            window.showModal("Benutzername nicht gefunden.");
                            return;
                        }

                        const userProfile = querySnapshot.docs[0].data();
                        const email = userProfile.email;
                        const isManagerFlag = userProfile.isManager || false;
                        
                        const userCredential = await signInWithEmailAndPassword(auth, email, password);

                        if (isManagerFlag) {
                            sessionStorage.setItem('currentManager', username);
                            loginModalOverlay.classList.add('hidden');
                            location.reload();
                            resolve(true);
                        } else {
                            await signOut(auth);
                            window.showModal("Dieses Konto ist keinem Gildenrat-Status zugeordnet.");
                            resolve(false);
                        }
                    } catch (error) {
                        console.error("Login-Fehler:", error);
                        let errorMessage = "Unbekannter Login-Fehler.";
                        if (error.code === 'auth/wrong-password' || error.code === 'auth/user-not-found' || error.code === 'auth/invalid-credential') {
                            errorMessage = "Falscher Benutzername oder falsches Passwort.";
                        } else if (error.code === 'auth/invalid-email') {
                            errorMessage = "Ungültiges E-Mail-Format (interner Fehler).";
                        }
                        window.showModal(errorMessage);
                        resolve(false);
                    }
                };

                const handleCancel = () => {
                    loginModalOverlay.classList.add('hidden');
                    resolve(false);
                };
				const handleKeydown = (event) => {
								if (event.key === 'Enter') {
									event.preventDefault();
									handleSubmit();
								}
							};
				loginUsernameInput.addEventListener('keydown', handleKeydown);
				loginPasswordInput.addEventListener('keydown', handleKeydown);
                loginSubmitBtn.addEventListener('click', handleSubmit);
                loginCancelBtn.addEventListener('click', handleCancel);

                loginModalOverlay.addEventListener('click', function clickOutside(event) {
                    if (event.target === loginModalOverlay) {
                        handleCancel();
                    }
                });
            });
        }
        
        // ============== AUTHENTIFIZIERUNG & PRESENCE ==============
        async function setupAuthUI() {
            const authSection = document.getElementById('auth-section');
            const currentManagerUsername = sessionStorage.getItem('currentManager');

            if (currentManagerUsername) {
                const q = query(userProfilesCollectionRef, where("username", "==", currentManagerUsername));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const userProfile = querySnapshot.docs[0].data();
                    if (userProfile.isManager) {
                        window.isManager = true;
                        authSection.innerHTML = `<span class="text-white">Angemeldet als: <strong>${currentManagerUsername}</strong></span><button id="logout-btn" class="ml-2 bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-md text-sm">Logout</button>`;
                        document.getElementById('logout-btn').addEventListener('click', async () => {
                            await signOut(auth);
                            sessionStorage.removeItem('currentManager');
                            location.hash = '';
                            location.reload();
                        });
                        return;
                    }
                }
                sessionStorage.removeItem('currentManager');
            }

            window.isManager = false;
            authSection.innerHTML = `<button id="login-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded-md text-sm">Gildenrat-Login</button>`;
            document.getElementById('login-btn').addEventListener('click', showLoginModal);
        }

        onAuthStateChanged(auth, user => {
            const presenceIndicator = document.getElementById('presence-indicator');
            if (heartbeatIntervalId) clearInterval(heartbeatIntervalId);

            if (!user) {
                signInAnonymously(auth).catch(e => console.error("Anonymer Login-Fehler:", e));
                presenceIndicator.innerHTML = `<div class="w-3 h-3 bg-gray-500 rounded-full"></div><span>0</span> Online`;
                return;
            }

            const userStatusRef = doc(db, "presence", user.uid);
            const updatePresenceTimestamp = () => {
                setDoc(userStatusRef, { online: true, last_changed: serverTimestamp() }, { merge: true });
            };
            updatePresenceTimestamp();
            heartbeatIntervalId = setInterval(updatePresenceTimestamp, 5 * 60 * 1000);

            onSnapshot(collection(db, "presence"), snap => {
                const nowInSeconds = Date.now() / 1000;
                const onlineUsersCount = snap.docs.filter(doc => {
                    const data = doc.data();
                    return data.online && data.last_changed && (nowInSeconds - data.last_changed.seconds < 360);
                }).length;
                presenceIndicator.innerHTML = `<div class="w-3 h-3 bg-green-400 rounded-full animate-pulse"></div><span>${onlineUsersCount}</span> Online`;
            });
        });

        // ============== NAVIGATION & CONTENT LOADING ==============
        const contentContainer = document.getElementById('content-container');
        const bossNav = document.getElementById('boss-nav');
        const raidSelector = document.getElementById('raid-selector');

        function updateBossNav(raidId) {
            const raid = raidData[raidId];
            if (!raid) {
                bossNav.innerHTML = '';
                return;
            }
            
            let navHTML = `<a href="#comp" data-page-id="comp" class="nav-link bg-green-700 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">Übersicht & Comp</a>`;
            
            raid.bosses.forEach(boss => {
                const pageId = `${raidId}/${boss.id}`;
                navHTML += `<a href="#${pageId}" data-page-id="${pageId}" class="nav-link hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">${boss.name}</a>`;
            });

            navHTML += `<a href="#history" data-page-id="history" class="nav-link bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">Änderungsverlauf</a>`;
            bossNav.innerHTML = navHTML;
        }

        async function loadContent(pageId) {
            if (currentRosterUnsubscribe) { currentRosterUnsubscribe(); currentRosterUnsubscribe = null; }
            if (historyUnsubscribe) { historyUnsubscribe(); historyUnsubscribe = null; }
            if (assignmentUnsubscribe) { assignmentUnsubscribe(); assignmentUnsubscribe = null; }

            const filePath = pageId.includes('/') ? `${pageId}.html` : `${pageId}.html`;

            try {
                const response = await fetch(filePath);
                if (!response.ok) throw new Error(`Seite ${filePath} nicht gefunden.`);
                contentContainer.innerHTML = await response.text();
                const actualPageIdForInit = pageId.includes('/') ? pageId.split('/')[1] : pageId;
                initializePage(actualPageIdForInit);
            } catch (error) {
                console.error("Fehler beim Laden des Inhalts:", error);
                contentContainer.innerHTML = `<div class="text-center p-8 bg-slate-850 rounded-lg"><h2 class="text-2xl font-semibold text-yellow-400">Inhalt nicht gefunden</h2><p class="mt-2 text-gray-400">Für diesen Boss wurde noch keine Seite angelegt. Bitte erstelle die Datei <code>${filePath}</code>.</p></div>`;
            }
        }

        function renderCurrentState() {
            const currentRaidId = raidSelector.value;
            updateBossNav(currentRaidId);

            let pageId = window.location.hash.substring(1) || 'comp';
            
            if (pageId.includes('/')) {
                const raidOfPage = pageId.split('/')[0];
                if (raidData[raidOfPage] && raidSelector.value !== raidOfPage) {
                    raidSelector.value = raidOfPage;
                    updateBossNav(raidOfPage);
                }
            }
            
            loadContent(pageId);

            document.querySelectorAll('#boss-nav .nav-link').forEach(link => {
                link.classList.toggle('active-tab', link.dataset.pageId === pageId);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            setupAuthUI();

            raidSelector.addEventListener('change', () => {
                // ++ KORRIGIERTE LOGIK ++
                // Wenn der User den Raid wechselt, soll zur #comp Seite navigiert werden.
                // Wenn wir schon auf #comp sind, würde das `hashchange` Event nicht feuern.
                // Deshalb rufen wir in diesem Fall die Render-Funktion manuell auf.
                // Andernfalls setzen wir den Hash, was das Event automatisch auslöst.
                if (window.location.hash === '#comp' || window.location.hash === '') {
                    renderCurrentState();
                } else {
                    window.location.hash = '#comp';
                }
            });

            window.addEventListener('hashchange', renderCurrentState);
            
            // Initialer Seitenaufbau
            renderCurrentState();
        });
        
        // ============== LOGGING-FUNKTION ==============
        window.logHistory = async function(boss, assignment, player, editor) {
             await addDoc(historyCollectionRef, {
                boss: boss,
                assignment: assignment,
                player: player,
                editor: editor,
                timestamp: serverTimestamp()
            });
        };

        // ============== SEITEN-INITIALISIERUNG ==============
        function initializePage(pageId) {
            if (pageId === 'comp') initCompPage();
            else if (pageId === 'history') initHistoryPage();
            else initBossPage(pageId);
        }

        // --- Logik für comp.html ---
        function initCompPage() {
            document.getElementById('import-btn')?.addEventListener('click', handleImportRoster);
            document.getElementById('add-player-btn')?.addEventListener('click', handleAddPlayer);
            document.getElementById('clear-roster-btn')?.addEventListener('click', handleClearRoster);

            currentRosterUnsubscribe = onSnapshot(rosterDocRef, (docSnap) => {
                const jsonInput = document.getElementById('json-input');
                const currentRosterData = docSnap.exists() ? docSnap.data().roster || [] : [];
                displayRoster(currentRosterData);
                if (window.updateRaidBuffsDisplay) {
                    window.updateRaidBuffsDisplay(currentRosterData);
                }
                if(jsonInput && jsonInput.value === ''){
                     jsonInput.value = docSnap.data().rawJson || '';
                }
            });
            window.toggleCompEditability();
        }

        // --- Logik für history.html ---
        function initHistoryPage() {
            const q = query(historyCollectionRef, orderBy("timestamp", "desc"));
            const tableBody = document.getElementById('history-table-body');
            if (!tableBody) return;
            historyUnsubscribe = onSnapshot(q, (querySnapshot) => {
                tableBody.innerHTML = '';
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const row = tableBody.insertRow();
                    row.innerHTML = `
                        <td class="px-6 py-4">${data.boss || 'Allgemein'}</td>
                        <td class="px-6 py-4">${data.assignment}</td>
                        <td class="px-6 py-4 font-medium">${data.player}</td>
                        <td class="px-6 py-4">${data.editor}</td>
                        <td class="px-6 py-4">${data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleString('de-DE') : 'Unbekannt'}</td>
                    `;
                });
            });
        }

        // --- Logik für Boss-Seiten ---
        function initBossPage(pageId) {
            const assignmentsDocRef = doc(db, DATA_COLLECTION, "boss-" + pageId);
            const sizeToggle = document.getElementById('size-toggle');
            if (sizeToggle) {
                sizeToggle.addEventListener('click', function(event) {
                    if (event.target.matches('.size-toggle-btn')) {
                        const selectedSize = event.target.dataset.size;
                        document.querySelectorAll('.size-toggle-btn').forEach(button => button.classList.remove('active-size-btn'));
                        event.target.classList.add('active-size-btn');
                        document.querySelectorAll('.tactic-content').forEach(content => {
                            content.style.display = content.dataset.size === selectedSize ? (content.tagName === 'SPAN' ? 'inline' : 'block') : 'none';
                        });
                    }
                });
                const defaultSizeButton = document.querySelector(`#size-toggle button[data-size="25"]`);
                if (defaultSizeButton) defaultSizeButton.classList.add('active-size-btn');
                document.querySelectorAll('.tactic-content').forEach(content => {
                    content.style.display = content.dataset.size === '25' ? (content.tagName === 'SPAN' ? 'inline' : 'block') : 'none';
                });
            }

            async function handleAssignmentChange(event) {
                if (!window.isManager) return;
                const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
                const select = event.target;
                const assignmentId = select.dataset.assignmentId;
                const playerName = select.value || "Niemand";
                await setDoc(assignmentsDocRef, { [assignmentId]: { player: playerName, editor: currentManager, timestamp: serverTimestamp() } }, { merge: true });
                const bossName = pageId.charAt(0).toUpperCase() + pageId.slice(1);
                const assignmentName = assignmentId.replace(pageId + '-', '').replace(/([A-Z])/g, ' $1').trim();
                window.logHistory(bossName, `Einteilung: ${assignmentName}`, playerName, currentManager);
            }

            (async () => {
                const rosterSnap = await getDoc(rosterDocRef);
                const rosterData = rosterSnap.exists() ? rosterSnap.data().roster || [] : [];
                
                function populateDropdownOptions(selectElement, players) {
                    selectElement.innerHTML = '<option value="" data-color="#FFFFFF">-- Spieler wählen --</option>';
                    players.forEach(player => {
                        const option = document.createElement('option');
                        const color = window.classColors[player.class.toUpperCase()] || '#FFFFFF';
                        option.value = player.name;
                        option.textContent = `${player.name} (${player.class})`;
                        option.style.color = color;
                        option.dataset.color = color;
                        selectElement.appendChild(option);
                    });
                }
                
                document.querySelectorAll('.assignment-select').forEach(select => {
                    select.addEventListener('change', handleAssignmentChange);
                    const assignmentId = select.dataset.assignmentId.toLowerCase();
                    let playersForDropdown = [];
                    if (assignmentId.includes('tank')) playersForDropdown = rosterData.filter(p => p.roles.includes('TANK'));
                    else if (assignmentId.includes('healer')) playersForDropdown = rosterData.filter(p => p.roles.includes('HEALER'));
                    else if (assignmentId.includes('dps') || assignmentId.includes('dd')) playersForDropdown = rosterData.filter(p => p.roles.includes('DPS'));
                    else playersForDropdown = rosterData;
                    populateDropdownOptions(select, playersForDropdown);
                });

                assignmentUnsubscribe = onSnapshot(assignmentsDocRef, (docSnap) => {
                    const assignments = docSnap.exists() ? docSnap.data() : {};
                    document.querySelectorAll('.assignment-select').forEach(select => {
                        const id = select.dataset.assignmentId;
                        const assignment = assignments[id];
                        const assignedPlayerName = assignment ? assignment.player : "";
                        select.value = assignedPlayerName;
                        const selectedOption = Array.from(select.options).find(o => o.value === assignedPlayerName);
                        select.style.color = selectedOption ? selectedOption.dataset.color : '#FFFFFF';
                    });
                    window.toggleSelectEditability();
                });
                window.toggleSelectEditability();
            })();
        }

        // ============== COMP LOGIK (HELFERFUNKTIONEN) ==============
        function getPlayerInfoFromEntry(playerEntry) {
            let playerClass = playerEntry.class ? playerEntry.class.toUpperCase() : 'UNKNOWN';
            if (playerClass === 'DK') playerClass = 'DEATHKNIGHT';
            let spec = playerEntry.spec;
            const specToClassMap = { 'Guardian': 'DRUID', 'Blood_Tank': 'DEATHKNIGHT', 'Protection': 'WARRIOR', 'Protection1': 'PALADIN', 'Brewmaster': 'MONK' };
            if ((playerClass === 'TANK' || specToClassMap[spec]) && spec) {
                const classFromSpec = specToClassMap[spec];
                if (classFromSpec) playerClass = classFromSpec;
            }
            const tankSpecs = ['Guardian', 'Blood_Tank', 'Protection', 'Protection1', 'Brewmaster'];
            const healerSpecs = ['Restoration', 'Restoration1', 'Discipline', 'Holy', 'Holy1', 'Mistweaver'];
            let role = 'DPS';
            if (tankSpecs.includes(spec)) role = 'TANK';
            else if (healerSpecs.includes(spec)) role = 'HEALER';
            return { name: playerEntry.name, class: playerClass, roles: [role], id: crypto.randomUUID() };
        }

		function displayRoster(roster) {
			const lists = { TANK: document.getElementById('tanks-list'), HEALER: document.getElementById('healers-list'), DPS: document.getElementById('dps-list') };
			if (!lists.TANK) return;
			Object.values(lists).forEach(list => list.innerHTML = '');
		
			function createPlayerElement(player) {
				const playerDiv = document.createElement('div');
				// Die Klasse für die responsive Anpassung bleibt erhalten
				playerDiv.className = 'flex justify-between items-center player-row-container'; 
				playerDiv.dataset.playerId = player.id;
			
				const roleIcons = {
					TANK: '🛡️',
					HEALER: '❤️',
					DPS: '⚔️'
				};
			
				playerDiv.innerHTML = `
					<div class="player-details">
						<input type="text" value="${player.name}" class="editable-name" style="color: ${window.classColors[player.class.toUpperCase()] || '#FFFFFF'};" ${!window.isManager ? 'disabled' : ''}>
						<select class="editable-class-select" ${!window.isManager ? 'disabled' : ''}>
							${wowClasses.map(c => `<option value="${c}" ${player.class === c ? 'selected' : ''}>${c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()}</option>`).join('')}
						</select>
					</div>
					<div class="flex gap-1">
						${['TANK', 'HEALER', 'DPS'].map(role => `
							<button 
								class="role-btn role-${role.toLowerCase()} ${player.roles.includes(role) ? 'active' : ''}" 
								data-role="${role}" 
								${!window.isManager ? 'disabled' : ''}
								style="font-size: 1.25rem; line-height: 1; padding: 0.25rem;"
							>
								${roleIcons[role]} 
							</button>
						`).join('')}
					</div>`;
				return playerDiv;
			}
		
			roster.forEach(player => {
				const playerElement = createPlayerElement(player);
				if (player.roles.includes('TANK')) lists.TANK.appendChild(playerElement.cloneNode(true));
				if (player.roles.includes('HEALER')) lists.HEALER.appendChild(playerElement.cloneNode(true));
				if (player.roles.includes('DPS')) lists.DPS.appendChild(playerElement.cloneNode(true));
			});
		
			roster.forEach(player => {
				document.querySelectorAll(`[data-player-id="${player.id}"]`).forEach(element => {
					const nameInput = element.querySelector('.editable-name');
					nameInput?.addEventListener('blur', (e) => handlePlayerUpdate(e, player.id, 'name'));
					nameInput?.addEventListener('keydown', (event) => {
						if (event.key === 'Enter') {
							event.preventDefault();
							event.target.blur(); // Simuliert das Verlassen des Feldes
						}
					});
					const classSelect = element.querySelector('.editable-class-select');
					classSelect?.addEventListener('change', (e) => handlePlayerUpdate(e, player.id, 'class'));
					element.querySelectorAll('.role-btn').forEach(btn => btn.addEventListener('click', () => togglePlayerRole(player.id, btn.dataset.role)));
				});
			});
		
			['TANK', 'HEALER', 'DPS'].forEach(role => {
				if(lists[role] && lists[role].children.length === 0) lists[role].innerHTML = `<p class="text-gray-500">Keine ${role.toLowerCase()}s zugewiesen.</p>`;
			});
			window.toggleCompEditability();
		}

        window.toggleSelectEditability = function() {
            document.querySelectorAll('.assignment-select').forEach(el => { el.disabled = !window.isManager; });
        };
        window.toggleCompEditability = function() {
            if(!document.getElementById('import-btn')) return;
            document.querySelectorAll('#import-btn, #add-player-btn, #clear-roster-btn, .editable-name, .editable-class-select, .role-btn').forEach(el => { el.disabled = !window.isManager; });
        };

        async function handlePlayerUpdate(event, playerId, field) {
            if (!window.isManager) return;
            const docSnap = await getDoc(rosterDocRef);
            if (!docSnap.exists()) return;

            const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
            let roster = docSnap.data().roster || [];
            const playerIndex = roster.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return;

            const oldPlayer = {...roster[playerIndex]};
            const newValue = event.target.value.trim();

            if (field === 'name' && newValue === '') {
                const deletedPlayerName = oldPlayer.name;
                roster.splice(playerIndex, 1);
                await updateDoc(rosterDocRef, { roster: roster });
                window.logHistory('Roster', 'Spieler gelöscht', deletedPlayerName, currentManager);
                window.showModal(`Spieler '${deletedPlayerName}' wurde gelöscht.`);
            } else {
                roster[playerIndex][field] = newValue;
                await updateDoc(rosterDocRef, { roster: roster });
                const changeText = field === 'name' ? `umbenannt in ${newValue}` : `Klasse geändert zu ${newValue}`;
                window.logHistory('Roster', `${oldPlayer.name} ${changeText}`, '', currentManager);
            }
        }

        async function togglePlayerRole(playerId, roleToToggle) {
            if (!window.isManager) return;
            const docSnap = await getDoc(rosterDocRef);
            if (!docSnap.exists()) return;

            const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
            let roster = docSnap.data().roster || [];
            const player = roster.find(p => p.id === playerId);
            if (!player) return;

            let changeText = '';
            const roleIndex = player.roles.indexOf(roleToToggle);
            if (roleIndex > -1) {
                if(player.roles.length > 1) {
                    player.roles.splice(roleIndex, 1);
                    changeText = `Rolle ${roleToToggle} entfernt`;
                }
            } else {
                player.roles.push(roleToToggle);
                changeText = `Rolle ${roleToToggle} hinzugefügt`;
            }

            if(changeText) {
                await updateDoc(rosterDocRef, { roster: roster });
                window.logHistory('Roster', changeText, player.name, currentManager);
            }
        }

        async function handleImportRoster() {
            if (!window.isManager) return;
            const jsonString = document.getElementById('json-input').value;
            if (!jsonString) return window.showModal("Bitte JSON einfügen.");
            try {
                const data = JSON.parse(jsonString);
                if (!data.raidDrop || !Array.isArray(data.raidDrop)) throw new Error("Ungültiges JSON: 'raidDrop' Array fehlt.");
                const newRoster = data.raidDrop.map(getPlayerInfoFromEntry);
                await setDoc(rosterDocRef, { roster: newRoster, rawJson: jsonString });
                const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
                window.logHistory('Roster', `Importiert`, `${newRoster.length} Spieler`, currentManager);
                window.showModal(`Roster mit ${newRoster.length} Spielern importiert!`);
            } catch (error) {
                window.showModal("Fehler beim Verarbeiten des JSON: " + error.message);
            }
        }

        async function handleAddPlayer() {
            if (!window.isManager) return;
            const name = prompt("Name des neuen Spielers:", "NeuerSpieler");
            if (!name) return;
            const newPlayer = { id: crypto.randomUUID(), name: name, class: 'WARRIOR', roles: ['DPS'] };
            const docSnap = await getDoc(rosterDocRef);
            const roster = docSnap.exists() ? docSnap.data().roster || [] : [];
            roster.push(newPlayer);
            await setDoc(rosterDocRef, { roster: roster }, { merge: true });
            const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
            window.logHistory('Roster', `Spieler hinzugefügt`, name, currentManager);
            window.showModal(`Spieler '${name}' wurde hinzugefügt.`);
        }

        async function handleClearRoster() {
            if (!window.isManager) return;
            const confirmed = await window.showModal("Sollen wirklich alle Spieler aus dem Roster entfernt werden?", true);
            if (confirmed) {
                await setDoc(rosterDocRef, { roster: [], rawJson: '' });
                document.getElementById('json-input').value = '';
                const currentManager = sessionStorage.getItem('currentManager') || 'Unbekannt';
                window.logHistory('Roster', 'Geleert', '', currentManager);
                window.showModal("Roster wurde geleert.");
            }
        }

        // ============== RAID BUFF LOGIK ==============
        const raidBuffsClassesMap = {
            // Offensive Buffs
            "5% Stärke, Beweglichkeit, Intelligenz": { classes: { "PALADIN": "Segen der Könige", "DRUID": "Mal der Wildnis", "MONK": "Vermächtnis des Kaisers", "HUNTER": "Umarmung der Schieferkrabbe (Pet)" } },
            "10% Angriffskraft": { classes: { "DEATHKNIGHT": "Horn des Winters", "HUNTER": "Trueshot Aura", "WARRIOR": "Kampfruf" } },
            "10% Angriffsgeschwindigkeit": { classes: { "DEATHKNIGHT": "Unholy Aura", "HUNTER": ["Kicherndes Heulen (Hyänen-Pet)", "Schlangenschnelligkeit (Schlangen-Pet)"], "ROGUE": "List des Schnellklinglers", "SHAMAN": "Entfesselte Wut" } },
            "3000 Meisterschaft": { classes: { "HUNTER": ["Brüllen des Mutes (Katzen-Pet)", "Segen des Geisterbestien (Geisterbestien-Pet)"], "PALADIN": "Segen der Macht", "SHAMAN": "Anmut der Luft" } },
            "5% Kritische Trefferchance": { classes: { "DRUID": "Anführer der Meute", "HUNTER": ["Furchterregendes Brüllen (Wolfs-Pet)", "Ruhiges Wasser (Wasserläufer-Pet)"], "MAGE": "Arkane Brillanz", "MONK": "Vermächtnis des Weißen Tigers", "PRIEST": "Inneres Feuer" } },
            "10% Zaubermacht": { classes: { "HUNTER": "Ruhiges Wasser (Wasserläufer-Pet)", "MAGE": "Arkane Brillanz", "SHAMAN": "Brennender Zorn", "WARLOCK": "Dunkle Absicht" } },
            "5% Zaubertempo": { classes: { "DRUID": "Mondkingestalt", "HUNTER": "Gedankenstärkung (Sporebat-Pet)", "PRIEST": "Schattenform", "SHAMAN": "Elementarer Eid" } },
            // Defensive Buffs
            "10% Ausdauer": { classes: { "HUNTER": "Qiraji-Standhaftigkeit (Silithiden-Pet)", "PRIEST": "Machtwort: Seelenstärke", "WARLOCK": "Dunkle Absicht", "WARRIOR": "Befehlsruf" } },
            "-10% physischer Schaden (Weakened Blows)": { classes: { "DEATHKNIGHT": "Scharlachrotes Fieber (Blut)", "DRUID": "Verwüsten", "HUNTER": ["Demoralisierendes Gebrüll (Bären-Pet)", "Demoralisierender Schrei (Aasvogel-Pet)"], "MONK": "Fass-Sturm (Braumeister)", "PALADIN": "Hammer des Rechtschaffenen (Schutz/Vergeltung)", "SHAMAN": "Erdbeben (Elementar/Verstärkung)", "WARLOCK": "Fluch der Entkräftung", "WARRIOR": "Donnerknall" } },
            // Debuffs (für Gegner)
            "+4% erlittener physischer Schaden (Physical Vulnerability)": { classes: { "DEATHKNIGHT": ["Spröde Knochen (Frost/Unheilig)", "Ebonplaguesprenger (Frost/Unheilig)"], "HUNTER": ["Gore (Eber-Pet)", "Stampede (Nashorn-Pet)", "Säurespucke (Wurm-Pet)", "Verwüsten (Schreiter-Pet)"], "PALADIN": "Urteile des Kühnen (Vergeltung)", "WARRIOR": "Kolossales Zerschmettern (Waffen/Furor)" } },
            "-4% Rüstung (Weakened Armor)": { classes: { "DRUID": "Feenfeuer", "HUNTER": ["Rüstung zerreißen (Raptoren-Pet)", "Staubwolke (Langbein-Pet)"], "ROGUE": "Rüstung zerreißen", "WARRIOR": ["Rüstung zerreißen (Waffen/Furor)", "Verwüsten (Schutz)"] } },
            "+5% erlittener Zauberschaden": { classes: { "HUNTER": ["Feueratem (Drachenfalken-Pet)", "Blitzatem (Windnatter-Pet)"], "ROGUE": "Meistergiftmischer", "WARLOCK": "Fluch der Elemente" } },
            "Heilungsreduktion (Mortal Wounds)": { classes: { "HUNTER": ["Witwengift", "Monströser Biss (Teufelssaurier-Pet)"], "MONK": "Aufsteigende Sonnenkick (Windläufer)", "ROGUE": "Wundgift", "WARRIOR": ["Tödlicher Stoß (Waffen/Furor)", "Wilder Stoß (Waffen/Furor)"] } },
            "Zaubergeschwindigkeitsreduktion": { classes: { "DEATHKNIGHT": "Nekrotischer Stoß", "HUNTER": ["Lava-Atem (Kernhund-Pet)", "Sporenwolke (Sporebat-Pet)"], "MAGE": "Verlangsamen (Arkan)", "ROGUE": "Gedankenbenebelndes Gift", "WARLOCK": "Fluch der Entkräftung" } },
            // Raid Cooldowns
            "Blutdurst/Heldentum": { classes: { "SHAMAN": "Blutdurst", "MAGE": "Zeitkrümmung", "HUNTER": "Uralte Hysterie (Exotisches Kernelementar-Pet)" } },
            "Schädelfahne": { classes: { "WARRIOR": "Schädelfahne" } },
            "Sturmhagel-Totem": { classes: { "SHAMAN": "Sturmhagel-Totem" } },
            "Antimagische Zone": { classes: { "DEATHKNIGHT": "Antimagische Zone" } },
            "Demoralisierende Standarte": { classes: { "WARRIOR": "Demoralisierende Standarte" } },
            "Hingabe-Aura": { classes: { "PALADIN": "Hingabe-Aura" } },
            "Machtwort: Barriere": { classes: { "PRIEST": "Machtwort: Barriere" } },
            "Sammelruf": { classes: { "WARRIOR": "Sammelruf" } },
            "Rauchbombe": { classes: { "ROGUE": "Rauchbombe" } },
            "Geisterverbindungstotem": { classes: { "SHAMAN": "Geisterverbindungstotem" } }
        };

        window.updateRaidBuffsDisplay = function(roster) {
            if (!roster) return;

            const rosterClassCounts = {};
            roster.forEach(player => {
                const playerClass = player.class.toUpperCase();
                rosterClassCounts[playerClass] = (rosterClassCounts[playerClass] || 0) + 1;
            });

            document.querySelectorAll('.buff-item').forEach(buffItem => {
                const buffName = buffItem.dataset.buffName;
                const buffData = raidBuffsClassesMap[buffName];
                const buffInfoSpan = buffItem.querySelector('.buff-info');
                if (!buffInfoSpan) return;

                let availableCount = 0;
                let tooltipLines = [];

                if (buffData && buffData.classes) {
                    for (const className in buffData.classes) {
                        const countInRoster = rosterClassCounts[className] || 0;
                        if (countInRoster > 0) {
                            availableCount += countInRoster;
                            const classAbility = buffData.classes[className];
                            const abilityNames = Array.isArray(classAbility) ? classAbility : [classAbility];
                            const color = window.classColors[className] || '#FFFFFF';
                            abilityNames.forEach(abilityName => {
                                 tooltipLines.push(`<span style="color: ${color};">${className.charAt(0).toUpperCase() + className.slice(1).toLowerCase()}</span>: ${abilityName}`);
                            });
                        }
                    }
                }

                if (availableCount > 0) {
                    buffItem.classList.remove('opacity-50');
                    buffItem.style.fontWeight = 'bold';
                    buffItem.style.color = 'inherit';
                    buffInfoSpan.textContent = ` (${availableCount})`;
                } else {
                    buffItem.classList.add('opacity-50');
                    buffItem.style.fontWeight = 'normal';
                    buffItem.style.color = '#a0aec0';
                    buffInfoSpan.textContent = ` (0)`;
                }

                buffItem.style.position = 'relative';
                buffItem.style.cursor = 'help';
                
                let tooltipDiv = buffItem.querySelector('.buff-tooltip');
                if (!tooltipDiv) {
                    tooltipDiv = document.createElement('div');
                    tooltipDiv.className = 'buff-tooltip hidden';
                    buffItem.appendChild(tooltipDiv);
                }
                tooltipDiv.innerHTML = tooltipLines.join('<br>');

                buffItem.onmouseover = () => {
                    if (tooltipLines.length > 0) {
                        tooltipDiv.classList.remove('hidden');
                    }
                };
                buffItem.onmouseout = () => {
                    tooltipDiv.classList.add('hidden');
                };
            });
        };
    </script>
</body>
</html>